\input texinfo @c -*- Mode: texinfo; Fill-column: 70; coding: utf-8 -*-
@c %**start of header
@setfilename guile-ncurses.info
@documentencoding UTF-8
@include version.texi
@settitle GUILE NCURSES @value{VERSION}

@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp

@c %**end of header


@copying
This manual is for the GNU Guile-NCurses library, (version
@value{VERSION}, @value{UPDATED}).  It provides bindings for the
ncurses library, which provides functionality for updating character
screens.

Copyright @copyright{} 1998-2010,2011,2013 Free Software Foundation, Inc. @*
Copyright @copyright{} 2001-2005 Pradeep Padala @*

@quotation

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, distribute with modifications, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.

@end quotation
@end copying

@titlepage
@title GUILE NCURSES
@subtitle For version @value{VERSION}, @value{UPDATED}
@author Michael L. Gran
@author Pradeep Padala
@author Tom Dickey and the ncurses Team


@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@summarycontents

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top GUILE NCURSES
@insertcopying
@end ifnottex

@menu
* Introduction::
* Components of a Curses Interface::
* Types and encodings::
* Curses Tutorial::
* Curses Reference::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Authors::

Components of a Curses Interface

* Terminal Capabilities::
* Keyboards and Keys::
* Characters::
* Windows::

Types and encodings

* Character types::
* Opaque types::

Curses Tutorial

* Hello World!!!::
* Interactive sessions and @code{guile-ncurses-shell}::
* The Gory Details::
* Initialization::
* A word about windows::
* Output functions::
* Input functions::
* Attributes::
* Windows Tutorial::
* Colors::
* Interfacing with the keyboard::
* Interfacing with the mouse::
* Panels Library::
* Menu Library::
* Forms Library::

Hello World!!!

* Using the Guile Curses module::

Initialization

* Initialization Functions::
* An example::

Output functions

* The @code{addch} procedure::
* @code{addstr} class of functions::
* A simple @code{addstr} example::
* A word of caution::

@code{addstr} class of functions

* A simple @code{addstr} example::
* A word of caution::

Input functions

* @code{getch} class of functions::
* @code{getnstr} class of functions::
* An example of @code{getnstr} and @code{getch}::

Attributes

* The details::
* @code{attr-on!} vs @code{attr-set!}::
* @code{attr-get}::
* @code{chgat} function::

Windows Tutorial

* The basics::
* Let there be a window::
* Other functions::
* Other border functions::

Colors

* The basics of color::
* Changing color definitions::

Interfacing with the keyboard

* The basics of keys::
* A simple key usage example::

Interfacing with the mouse

* The basics of the mouse::
* Getting the events::
* Miscellaneous functions::

Panels Library

* Panels Basics::
* Compiling With the Panels Library::
* Moving and Resizing Panels::

Menu Library

* Menu Basics::
* Menu Driver::
* Menu Windows::
* Scrolling Menus::

Forms Library

* The Basics (Forms)::
* A Form Example::
* Making it useful::
* Playing with fields::
* Field Display Attributes::
* Field Option Bits::
* Field Status::
* Variable-Sized Fields::
* Form Windows::
* Field Validation::
* The Form Driver::

Curses Reference

* The naming of routines::
* The basic curses library::
* Function key labels library::
* The curses panel library::
* The curses menu library::
* The curses form library::

The basic curses library: @code{(ncurses curses)}

* Overview::
* Features determined at compile time::
* Curses screen initialization and manipulation routines::
* Errors and Exceptions::
* Making rendered characters::
* Adding characters::
* Adding strings of characters and attributes::
* Character and window attribute control routines::
* Bell and screen flash routines::
* Window background manipulation routines::
* Borders and lines::
* Clearing windows and parts of window::
* Color manipulation routines::
* Deleting the character under the cursor::
* Deleting and inserting lines::
* Getting characters from the keyboard::
* Handling unmapped keys::
* Receiving strings from the keyboard::
* Cursor location and window coordinates::
* Getting a rendered character from the window::
* Getting a string of characters and attributes from a window::
* Input options::
* Inserting a character before the cursor::
* Inserting a string before the cursor::
* Getting a string of characters from the screen::
* Low-level routines::
* Mouse handling::
* Moving the cursor ::
* Output options::
* Overlay and manipulate overlapped windows::
* Create and display pads::
* Print data to a terminal-attached ports::
* Refresh windows and lines::
* Reading and writing a curses screen to a file::
* Scroll a window::
* Terminal attributes::
* Refresh routines::
* Miscellaneous utilities::
* Window creation::

The Coordinate System


The curses menu library: @code{(ncurses menu)}

* Menus Overview::
* Menu Item Procedures::
* Menu Procedures::
* Menu creation ::
* Menu options::

Menu Procedures

* Menu Colors and Attributes::
* Positioning a menu cursor::
* The menu driver::
* Menu sizes::
* Menu mark strings::

Menu options

* Menu pattern buffer::
* Writing or erasing menus from window::
* Control spacing between menu items::
* Associate menus with window::

The curses form library: @code{(ncurses form)}

* Forms Overview::
* Form procedures::
* Making or breaking connections between forms and fields::
* Color and attribute control for form fields::
* Data type validation for fields::
* Creating forms::
* Form pagination functions::
* Setting and getting form options::
* Setting the page number and field::
* Writing or erasing forms from associated subwindows::
* Printable form request names::
* Form windows::

@end detailmenu
@end menu

@node Introduction, Components of a Curses Interface, Top, Top
@chapter Introduction

@menu
* Authors::
@end menu

@node Authors,  , Introduction, Introduction
@section Authors, Copyright, and Declarations

Michael Gran assembled this book, but, wrote only small sections of
text.  Most of reference text of the curses library was taken directly
from the documentation of ncurses itself and was modified to make it
specific to this Guile binding.  The ncurses library is maintained by
Tom Dickey, and the manual pages in the library note that the Free
Software Foundation holds the copyright.

I've put his name on the title page, because it would seem rude not to
do so; however, one should not get the impression that he approves of
the Guile Ncurses project or that he is involved with the Guile
NCurses project, or, indeed, that he is even aware of it.

The license for the original ncurses documentation is as follows.

@quotation
Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, distribute with modifications, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.
@end quotation

The tutorial for the curses library is adapted from the @emph{ncurses
Programming HowTo} by Pradeep Padala.  It was modified by Michael Gran
to make it specific to the Guile binding.

Again, I've put his name on the title page, because it would seem rude
not to do so; however, one should not get the impression that he
approves of the Guile Ncurses project or that he is involved with the
Guile Ncurses project, or, again, that he is even aware of it.

That document holds the following license.

@quotation

Copyright @copyright{} 2001, 2002, 2005 Pradeep Padala

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, publish,
distribute, distribute with modifications, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions.

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.
@end quotation

@node Components of a Curses Interface, Types and encodings, Introduction, Top
@chapter Components of a Curses Interface

The goal of Ncurses is to simplify the task of programming for
character-cell terminals.  A character-cell terminal is a combination
of a display that shows text in a monospaced font and the keyboard and
mouse that connect to it.  These days, there are three common types of
terminals.  Actual hardware terminals, such as the DEC VT220 or the
Boundless Technologies VT525, are dedicated thin clients that interact
with a networked computer via a serial port.  These are still somewhat
common in legacy applications or industrial applications where
computers would be too expensive or too fragile, but, they are rapidly
becoming extinct.  Second are the consoles of text-mode operating
systems, such as the console of GNU/Linux when used without X/Windows
or the command prompt of FreeDOS.  The third type is the terminal
emulation programs that some windowing systems have.  The best known
terminal emulation program is probably XTerm, which does a good
emulation of a VT220 terminal.

The Ncurses library attempts to create a standardized solution for
these problems.
@itemize @bullet
@item
A program needs to know which keys are pressed and when.
@item
A program needs to know a terminal's capabilities. Can text be bold,
italic, or in color?
@item
A program needs to know how to exploit a terminal's capabilities.  How
does a program tell the terminal to move the cursor, to change text
color, or to erase the screen?
@end itemize

@menu
* Terminal Capabilities::
* Keyboards and Keys::
* Characters::
* Windows::
@end menu

@node Terminal Capabilities, Keyboards and Keys, Components of a Curses Interface, Components of a Curses Interface
@section Terminal Capabilities

@cindex terminfo
@cindex termcap

The first step in any Ncurses program is to understand the terminal's
capabilities and attributes.  Ncurses includes a database of terminals
and their capabilities called @code{terminfo} or perhaps
@code{termcap}.  When a Ncurses program is initialized, the type of
terminal is queried, usually by examining the environment variable
@env{TERM}, and the capabilities are read from the database.

@node Keyboards and Keys, Characters, Terminal Capabilities, Components of a Curses Interface
@section Keyboards and Keys

When a key is pressed, one or more bytes are sent to the program by
the keyboard driver.  These bytes need to be converted by the program
back into a key name.  For @abbr{ASCII} characters, this conversion is
trivial.  A key press of @kbd{c} usually sends the @abbr{ASCII}
encoding 142 (@key{c}) which can be understood to mean the letter ``c''.
For other keys on the keypad, like @key{F1} or @key{HOME}, the
encoding can take multiple bytes and can differ from terminal to
terminal.  On some terminals, for example, pressing @key{F1} is the
same as if the user had typed @kbd{@key{ESC} O P}.

The @code{terminfo} database provides information that helps associate
multibyte codes to keys on the keypad, and there are curses functions
that will do the association.

@node Characters, Windows, Keyboards and Keys, Components of a Curses Interface
@section Characters, Attributes, Colors, and Renditions

As the goal of curses is to allow a program to take advantage of the
capabilities of terminal, each character on the screen has a
@dfn{color pair} and a set of @dfn{attributes}.

@cindex Color pairs
@cindex Attributes

In curses, the colors are usually defined in terms of  @dfn{color
pairs}, which is a combination of a foreground and a background
color.  Each character written to a terminal will have an associated
color pair, assuming the terminal supports color.

Also each character has a set of attributes, such as @dfn{bold},
@dfn{underline}, or @dfn{blink}.

@cindex Rendition

A character's color pair and its attributes are collectively called
its @dfn{rendition}.

@node Windows,  , Characters, Components of a Curses Interface
@section Windows

@cindex Windows

Curses uses the concept of a @dfn{window} to visually organize the
terminal.  A window is a rectangular area on the terminal.  A terminal
always has one default window which is the size of the physical
screen.  This may be further subdivided into other windows.  The
default window is called the @dfn{standard screen}.

Each window has a set of associated visual properties: the default
rendition of characters added to it and whether it scrolls when text
reaches the bottom of the screen, for example.

Each window forms a coordinate system for the display of characters.
The top-left character location in the window is the origin, (0, 0).
@var{x} coordinates increase as one moves right and @var{y}
coordinates increase as one moves down.  Because the origin begins at
zero, the largest allowable @var{x} value will be the number of
columns minus one.

@node Types and encodings, Curses Tutorial, Components of a Curses Interface, Top
@chapter Types and encodings

Curses has several types specific to how it operates: rendered strings
and windows, for example.  Some of the curses types are represented by
standard scheme types, while others are represented as opaque types
(SMOBs).

@menu
* Character types::
* Opaque types::
@end menu


@node Character types, Opaque types, Types and encodings, Types and encodings
@section Character types

@cindex Unicode
@cindex Characters

The Guile Ncurses library uses two basic character types, simple
characters and complex characters.  Simple characters are the native
Guile characters, and complex characters are those used to interact
with the NCurses library.  When using this library, a programmer will
often have to convert simple characters to complex characters and vice
versa, so it is important to understand their differences and
applications.

Simple characters are the Guile native character type.

For older versions of Guile, such as the 1.6.x and the 1.8.x versions,
characters were limited to being 8-bit.  The lower 128 characters were
ASCII, and the upper 128 characters had a meaning based on the locale
of the system.  If the locale were set to ISO-8859-1, for example, the
upper 128 characters would be common accented letters used in western
European languages.  In almost all cases, each character took up the
same space on a character cell terminal.

In newer versions of Guile, such as 2.0.x, the native Guile character
type is a Unicode codepoint, a 32-bit number.  Characters based on
Unicode include all or most of the glyphs for the most
languages. There are challenges when using the non-ASCII characters.
There are double-width characters, such as hiragana and katakana, that
take up two character spaces on a character cell terminal because of
their complexity.  There are combining characters, such as accents,
that aren't intended to stand alone and actually modify the previous
character in a string.

In the terminology of Unicode, a 32-bit integer that maps to a wide
character is a @dfn{code point}, and documents that refer to Unicode
code points typically write them like this: @code{U+XXXX}, where
@code{XXXX} is a four-digit hexadecimal number.


@table @code

@item simple characters

An simple character is a standard Guile character, such as @code{#\x}.
It is also referred to as an unrendered characters.  It is
@emph{unrendered} because it has no associated color or attributes.

@item simple strings

A simple string, also called an unrendered string, is a standard Guile
string, such as @code{"hello"}, which is a sequence of unrendered
characters.

@item complex characters
@tindex xchar

Rendered, complex characters usually are a standard character, zero to
three combining characters, attribute information, and color
information.  The @emph{attribute information} describes if the
character is bold, dim, reverse video, etc.  The guile ncurses library
defines a special record type for complex characters: the @dfn{xchar}.

Each complex character may contain more than one simple character.
The first character in the list should be a base character or a
control character.  A base character is usually a character than can
be printed standalone: combining accents and other letter codepoints
intended to modify another letter are not base characters. The
remaining characters in the list, if any, are accents or other
combining characters that modify the appearance of the base character.
If the first character was a control character, no combining
characters are allowed.

Here are examples of the constructors used to make complex characters.
These constructors will be described in more detail later on.
@example
;; A constructor for a letter 'x' using the default colors
> (normal #\x)

;; The display format of the resulting complex character
==> #<xchar #\x>

;; A constructor for a bold letter 'L' using default colors
> (bold #\L)

;; The display format of the resulting bold 'L' character
==> #<xchar bold #\L>

;; A bold letter 'x' printed white on a green background
> (init-pair! 2 COLOR_WHITE COLOR_GREEN)
> (bold-on (color 2 #\x))
==> #<xchar bold color-pair #2 [white on green] #\x>

;; A letter 'n' overwritten with a tilde
> (define ntilde (normal #\n))
> (set-xchar-chars! ntilde '(#\n #\~))
> ntilde
==> #<xchar #\n #\~>
@end example

@item rendered, complex strings
Rendered, complex strings are lists of rendered, complex characters.

An example of the constructor for a rendered complex string, and the
display format of that string
@example
;; The constructor for a complex string: the word 'hello' in
;; reverse video
> (inverse "hello")

;; The display format of the resulting string could be...
==> (#<xchar reverse color-pair #0 [white on black] #\h>
     #<xchar reverse color-pair #0 [white on black] #\e>
     #<xchar reverse color-pair #0 [white on black] #\l>
     #<xchar reverse color-pair #0 [white on black] #\l>
     #<xchar reverse color-pair #0 [white on black] #\o>)
@end example

@end table

@node Opaque types,  , Character types, Types and encodings
@section Opaque types

@cindex SMOBs used in Curses
@cindex Opaque types

These are types from system libraries that are complex or
system-dependent.  They are implemented as @code{SMOB}s.

@table @code

@item The @code{#<window>} type

@findex newwin

The @code{#<window>} type is an opaque type that contains information
about the characters and renditions for a given window.  It is created
by the function @code{newwin} and is used and most curses functions.

@item The @code{#<screen>} type

@tindex #<screen>
@findex newterm
@findex set-term

The @code{#<screen>} type is an opaque types that contain information
about the physical terminal.  Variables of type @code{#<screen>} are
created with the function @code{newterm} and used by the function
@code{set-term}.

This type is usually only found in programs that use multiple
terminals.

@item The @code{#<panel>} type

@tindex #<panel>
@findex new-panel

The @code{#<panel>} type is an opaque type that represents a window's
place in a stack of windows.  It is created with @code{new-panel}.  It
is used in functions that deal with overlapping windows

@item The @code{#<item>} type

@tindex #<item>
@findex new-item

The @code{#<item>} type is an opaque type that represents one menu
item in a menu.  It is created with @code{new-item}.  It is part of
the menu library.

@item The @code{#<menu>} type

@tindex #<menu>
@findex new-menu

The @code{#<menu>} type is an opaque type that represents a menu.
It is created with @code{new-menu} from a list of @code{#<item>}
types.

@item The @code{#<field>} type

@tindex #<field>

The @code{#<field>} type is an opaque type that represents one text
box or entry on a form.

@item The @code{#<form>} type

@tindex #<form>

This represents a form, created using @code{new-form} from a list of
elements of type @code{#<field>}.


@end table

@node Curses Tutorial, Curses Reference, Types and encodings, Top
@chapter Curses Tutorial

@menu
* Hello World!!!::
* Interactive sessions and @code{guile-ncurses-shell}::
* The Gory Details::
* Initialization::
* A word about windows::
* Output functions::
* Input functions::
* Attributes::
* Windows Tutorial::
* Colors::
* Interfacing with the keyboard::
* Interfacing with the mouse::
* Panels Library::
* Menu Library::
* Forms Library::
@end menu

@node Hello World!!!, Interactive sessions and @code{guile-ncurses-shell}, Curses Tutorial, Curses Tutorial
@section Hello World!!!

Welcome to the world of curses.  Before we plunge into the library and
look into its various features, let's write a simple program and say
hello to the world.

@menu
* Using the Guile Curses module::
@end menu

@node Using the Guile Curses module,  , Hello World!!!, Hello World!!!
@subsection Using the Guile Curses module

To use ncurses library functions, you have to load the @code{(ncurses
curses)} module into the program.

@cindex Hello, world

Here is the Hello World program.

@example
@verbatiminclude ex_hello_world.scm
@end example

The first line of the example, @code{#!/usr/bin/guile}, gives the
location of where Guile is installed on my system. This may differ on
your system.

The above program prints ``Hello World!!!'' to the screen, waits for
the user to press any key, and then exits.  This program shows how to
initialize curses and do screen manipulation and end curses mode.
Let's dissect it line by line.


@subsubsection About @code{initscr}

@cindex Initializing the terminal
@cindex Terminal initialization
@cindex Initialization

@findex initscr

The procedure @code{initscr} initializes the terminal in curses mode.
It clears the screen and presents a blank screen.  To do any screen
manipulation using the curses package, this has to be called first.
This function initializes the curses system and allocates memory for
screen handling and some other data structures.  It returns a SMOB
that represents the default window: the window that represents the
entire screen.  By convention, this window is denoted @code{stdscr},
the @emph{standard screen}.  Under extreme cases, this function might
fail due to insufficient memory to allocate memory for curses
library's data structures.

The procedure @code{initscr} returns a @code{#<window>} that contains
necessary information about the curses screen.  The @code{#<window>}
that is returned must be stored until the program is finished with the
curses library.  If that @code{#<window>} is garbage collected, the
curses library cannot continue.

After this is done, we can do a variety of initializations to
customize our curses settings

@subsubsection The mysterious @code{refresh}

@cindex Refreshing windows
@cindex Redrawing windows

The next line @code{addstr} prints the string ``Hello World!!!'' on to
the screen.  This function prints the data on a window called
@code{stdscr} at the current @code{(y, x)} coordinates.  Since our
present coordinates are at 0,0 the string is printed at the top,
left-hand corner of the window.

This brings us to the mysterious @code{(refresh stdscr)}.  Well, when
we called @code{addstr}, the data is actually written to an imaginary
window, which is not updated on the screen yet.  The job of
@code{addstr} is to update a few flags and data structures and write
the data to a buffer corresponding to @code{stdscr}.  In order to show
it on the screen, we need to call @code{refresh} and tell the curses
system to dump the contents on the screen.

The philosophy behind all this is to allow the programmer to do
multiple updates on the imaginary screen or windows and to do a
@code{refresh} once all the screen update is done.  @code{refresh}
checks the window and updates only the portion which has been
changed.  This improves performance and offers greater flexibility,
too.  But, it is sometimes frustrating to beginners.  A common mistake
committed by beginners is to forget to call @code{refresh} after they
did some update through @code{addstr}.

@subsubsection About @code{endwin}

@cindex Quitting Curses

And finally, don't forget to end the curses mode.  Otherwise your
terminal might behave strangely after the program quits.
@code{endwin} frees the memory taken by the curses sub-system and its
data structures and puts the terminal in normal mode.  This function
must be called after you are done with curses mode.

@node  Interactive sessions and @code{guile-ncurses-shell}, The Gory Details, Hello World!!!, Curses Tutorial
@section Interactive sessions and @code{guile-ncurses-shell}

@cindex guile-ncurses-shell

If you would like to try out these functions interactively by typing
them into the scheme shell, instead of typing them and running them
as scripts, the program @code{guile-ncurses-shell} can be used.  The
problem with interactive Guile sessions using @code{curses} is that
you are typing into the same screen that curses is trying to manage,
which leads to confusing results.  The program
@code{guile-ncurses-shell}, which must be run on X, starts an
interactive guile session and creates and @code{xterm} that will be
managed by curses.  The results of the curses function calls will
appear in the @code{xterm}, instead of in the screen where the
interactive guile session occurs.

Here we'll try four functions: @code{initscr} sets up the screen,
@code{addstr} writes a string to the screen, @code{refresh} redraws
the screen, and @code{endwin} frees the screen.

Upon initialization @code{guile-ncurses-shell} automatically calls these functions.
@lisp
(use-modules (ncurses curses))
(define %guile-ncurses-shell-stdscr (initscr))
@end lisp
@noindent It loads the ncurses module; initializes the screen; and
saves the returned ncurses screen structure in the variable
@code{%guile-ncurses-shell-stdscr}. Thus, you do not need to call
@code{(initscr)} in your interactive session when you use
@code{guile-ncurses-shell}.

@findex %guile-ncurses-shell-stdscr

The first thing you want to do is to redefine the name of the standard
window to something more reasonable.

@lisp
(define win %guile-ncurses-shell-stdscr)
@end lisp

To check and see if the guile-ncurses-shell is working, you can write
a string onto the created xterm.

@lisp
(addstr win "hello, world!")
(refresh win)
@end lisp

The guile-ncurses-shell communicates with the xterm using a read port
and a write port.  If, for some obscure reason, you need to access the
read or write port directly, they are stored in the variables
@code{%guile-ncurses-shell-read-port} and
@code{%guile-ncurses-shell-write-port}.

@findex %guile-ncurses-shell-read-port
@findex %guile-ncurses-shell-write-port

When exiting an interactive session, by @kbd{C-D} for example,
@code{guile-ncurses-shell} automatically calls @code{(endwin)}, so you
do not need to call that yourself.

@node The Gory Details, Initialization, Interactive sessions and @code{guile-ncurses-shell}, Curses Tutorial
@section The Gory Details

Now that we've seen how to write a simple curses program, let's get
into the details.  There are many functions that help customize what
you see on the screen and many features which can be put to full use.

Here we go@enddots{}

@node Initialization, A word about windows, The Gory Details, Curses Tutorial
@section Initialization

@cindex Initialization
@findex initscr

We now know that to initialize curses the function @code{initscr} has
to be called.  There are functions which can be called after this
initialization to customize our curses session.  We may ask the curses
system to set the terminal in raw mode or initialize color or
initialize the mouse, etc.  Let's discuss some of the functions that
are normally called immediately after @code{initscr}.

@menu
* Initialization Functions::
* An example::
@end menu

@node Initialization Functions, An example, Initialization, Initialization
@subsection Initialization Functions

@subsubsection @code{raw!} and @code{cbreak!}

@cindex Line buffering
@cindex Character buffering
@cindex Buffering
@cindex Signals, disabling

Normally the terminal driver buffers the characters a user types until
a newline or carriage return is encountered.  But most programs
require that the characters be available as soon as the user types
them. The functions @code{cbreak!} and @code{raw!} are used to disable
line buffering.  The difference between these two functions is in the
way control characters like suspend (@kbd{Ctrl-Z}), interrupt and quit
(@kbd{Ctrl-C}) are passed to the program.  In the @code{raw!} mode,
these characters are directly passed to the program without generating
a signal.  In the @code{cbreak!} mode, these control characters are
interpreted as any other character by the terminal driver, allowing
@kbd{Ctrl-C} and @kbd{Ctrl-Z} to quit and suspend the program.

@subsubsection @code{echo!} and @code{noecho!}

@cindex Echoing

These functions control the echoing of characters typed by the user to
the terminal.  @code{noecho!} switches off echoing. With echoing off,
when a user presses a character, it is not displayed on the screen.

@subsubsection keypad!

@cindex Function keys

This function enables the reading of function keys like @key{F1},
@key{F2}, arrow keys, etc.  Almost every interactive program enables
this, as arrow keys are a major part of any user interface.  Do
@code{(keypad! stdscr #t)} to enable this feature for the regular
screen @code{stdscr} (assuming that @code{stdscr} is the variable
you used to hold the output of @code{initscr}.)

@subsubsection halfdelay!

@cindex Half-delay mode
@cindex Line buffering

This function is useful when you want to ask the user for input, and
if he doesn't respond within a certain time, do something else.  One
possible example would be a  timeout at a password prompt.
@code{halfdelay!} enables half-delay mode, which is similar to
@code{cbreak!} mode in that characters types are immediately available
to the program.  However, after a period of time if there is no
input, it returns @code{#f}.

@node An example,  , Initialization Functions, Initialization
@subsection An example

Let's write a program that will clarify the usage of these functions.

@example
@verbatiminclude ex_init_func_usage.scm
@end example

Hopefully this program is easy to follow even though I used functions
that aren't explained yet.  The procedure @code{getch} is used to get
a character from the user.  If it returns a character, the user
pressed a character key.  If it returns a number, the use pressed a
function key. The @code{(bold ch)} adds the bold attribute to the
character, and @code{addch} prints the character on the screen.

@node A word about windows, Output functions, Initialization, Curses Tutorial
@section A word about windows

Before we plunge into the myriad ncurses functions, let me clear a few
things about windows.  Windows are explained in detail in the
following sections.

A window is an imaginary screen defined by the curses system.  A
window does not mean a bordered window which you usually see in GNOME
or KDE system.  When curses is initialized, it creates a default
window conventionally named @code{stdscr} which represents your 80x25
(or the size of window in which you are running) screen. If you are
doing simple tasks like printing a few strings, reading input, etc.,
you can safely use this single window for all of your purposes.  You
can also create windows and call functions which explicitly work on
the specified window.

For example, if you call
@example
(addstr stdscr "Hi There!!!")
(refresh stdscr)
@end example

It prints the string on @code{stdscr} at the present cursor position.
Similarly, the call to @code{refresh} works on @code{stdscr} only.

Say you have created multiple windows, then you have to call the
functions separately on each window.  When you call @code{refresh},
you need to call it on the window that was updated.
@example
(addstr win "Hi There!!!")
(refresh win)
@end example

For many functions, there are optional key parameters.
@example
(addstr stdscr string)             ; Print on stdscr at present
                                   ; cursor location
(addstr stdscr string #:y y #:x x) ; Move to (y, x) then print string
@end example

@node Output functions, Input functions, A word about windows, Curses Tutorial
@section Output functions

@cindex Output procedures
@cindex Print procedures

I guess you can't wait any more to see some action.  Back to our
odyssey of curses functions.  Now that curses is initialized, let's
interact with the world.

There are three primary functions which you can use to output
characters and strings to the screen.
@enumerate
@item
@code{addch}: output rendered characters
@item
@code{addstr}: output unrendered strings
@item
@code{addchstr}: output rendered strings
@end enumerate

@menu
* The @code{addch} procedure::
* @code{addstr} class of functions::
* A simple @code{addstr} example::
* A word of caution::
@end menu

@node The @code{addch} procedure, @code{addstr} class of functions, Output functions, Output functions
@subsection The @code{addch} procedure

@cindex Outputting characters

The @code{addch} function puts a single rendered character into the
current cursor location and advances the position of the cursor.
Attributes are explained in detail in later sections of the document.
If a character is associated with an attribute (bold, reverse video,
etc.), when curses prints the character, it is printed with that
rendition.

@cindex Attributes, adding to a character

In order to combine a character with some attributes, you have two
options:
@enumerate
@item
You can explicitly construct a rendered character by passing a simple
character through the rendition functions for the desired attributes:
@example
(bold #\x)
(blink-on (bold-on #\x))
(color 2 #\x)
@end example

@item
By using functions like @code{attr-set!}, @code{attr-on!},
@code{attr-off!}, you can manipulate the current attributes of the
given window.  Once set, the characters printed in the window are
associated with the attributes until it is turned off.
@end enumerate

Additionally, curses provides some special characters for
character-based graphics.  You can draw tables, horizontal or vertical
lines.  Try looking for the procedures beginning with @code{acs-}.

@subsubsection Moving the cursor addch

The optional key parameters @code{#:y y #:x x} can be used to move the
cursor to a given point, and then print.  Thus the calls
@example
(move stdscr row col)
(addch stdscr ch)
@end example
can be replaced by
@example
(addch stdscr ch #:y row #:x col)
@end example

@subsubsection Complex characters and @code{addch}

@cindex Outputting wide characters

There are really two version of the NCurses library: a standard
version and a @emph{wide} version.  When @code{guile ncurses} was
compiled, it was associated with either the standard version
@file{libncurses} or the wide version @file{libncursesw}.  The wide
version has greater capability to print non-Latin characters than the
standard version.

For every C function that operates on characters, there is a parallel
function that operates on wide characters.  The guile ncurses library
hides all of that complexity, and presents the same API regardless of
whether it used @file{libncurses} or @file{libncursew}.

At this point, a C programmer familiar with @code{ncurses} might be
wondering how to call @code{add-wch} to print, for example, a Chinese
character.  The guile ncurses library abstracts both the C ncurses
function @code{addch} and the C ncurses function @code{add-wch} as the
Guile function @code{addch}.

So, if you version of Guile is capable of Unicode characters (such as
Guile version 2.0.x), and if you version of NCurses is the wide
version @code{libncursesw}, then you can use this library to print
non-Latin characters.

First off, if you want to use wide characters, you need to call
@code{(setlocale LC_ALL "")} before the call to @code{initscr}.  The
locale that is set must be an encoding that has greater than 8-bit
characters, such as UTF-8.  Also, you terminal must be capable of
printing non-Latin characters.

Then, to add a rendered, complex character to the screen, use @code{addch}
and friends as before
@example
;; Bold U+041B Cyrillic Capital Letter El
(addch stdscr (bold #\Ð›))
@end example

@node @code{addstr} class of functions, A simple @code{addstr} example, The @code{addch} procedure, Output functions
@subsection @code{addstr} class of functions

@cindex Outputting strings

These functions output entire strings to the screen.

They can be used effectively in conjunction with the @code{format}
procedure from @code{(ice-9 format)}.

@menu
* A simple @code{addstr} example::
* A word of caution::
@end menu

@node A simple @code{addstr} example, A word of caution, @code{addstr} class of functions, Output functions
@subsection A simple @code{addstr} example

@example
@verbatiminclude ex_centered_screen.scm
@end example

The above program demonstrates how easy it is to combine @code{addstr}
and @code{move} to print at a specific location on the screen.  It
also shows how to use the equivalent key parameters @code{#:y} and
@code{#:x}.  They do exactly the same thing.  It also shows how
@code{(format #f @dots{})} can be used in conjunction with @code{addstr}
to do formatted output.

The example introduces the new function @code{getmaxyx}.  It gives the
number of columns and the number of rows in a given window.
@code{getmaxyx} does this by returning a list of two elements,
@code{y} and @code{x}.

@node A word of caution,  , A simple @code{addstr} example, Output functions
@subsection A word about coordinates

The @code{move} function takes the @code{y} coordinate first and then
@code{x} as its arguments.  A common mistake by beginners is to pass
@code{x}, @code{y} in that order.

If you use the @code{#:y} and @code{#:x} key parameters that most
output procedures have in lieu of using the @code{move} statement, you
can use enter the coordinates in whichever order seems most natural to
you.
@example
;; either
(addstr win "Hi" #:x 0 #:y 10)
;; or
(addstr win "Hi" #:y 10 #:x 0)
@end example

@node Input functions, Attributes, Output functions, Curses Tutorial
@section Input functions

Well, printing without taking input is boring.  Let's see functions
which allow us to get input from the user.
@enumerate
@item
@code{getch}: get a character
@item
@code{getnstr}: get a string
@end enumerate


@menu
* @code{getch} class of functions::
* @code{getnstr} class of functions::
* An example of @code{getnstr} and @code{getch}::
@end menu

@node @code{getch} class of functions, @code{getnstr} class of functions, Input functions, Input functions
@subsection @code{getch}
@cindex Inputting characters
@cindex Echoing

The procedure @code{getch} reads a single character from the terminal.
But there are several subtle facts to consider.  For example, if you
don't use the function @code{cbreak!}, curses will not read your input
characters contiguously, but, will begin to read them only after
@key{RET} has been pressed or after and @key{EOF} has been
encountered.  In order to avoid this, the @code{cbreak!} function must
be used so that characters are immediately available to your program.
Another widely used function is @code{noecho!}.  As the name suggests,
when this function is set (used), the characters that are keyed in by
the user will not show up on the screen.  The two functions
@code{cbreak!} and @code{noecho!} are typical examples of key
management.


@node @code{getnstr} class of functions, An example of @code{getnstr} and @code{getch}, @code{getch} class of functions, Input functions
@subsection @code{getnstr}

The @code{getnstr} procedure is used to get strings from the terminal.
In essence, it performs the same task as would be achieved by a series
of calls to @code{getch} until a @key{NL}, @key{CR}, or @key{EOF} is
received.  The resulting string of characters is returned.  The
procedure always takes a length parameter which is the maximum length
of string that it will allow to be input.

@node An example of @code{getnstr} and @code{getch},  , @code{getnstr} class of functions, Input functions
@subsection An example of @code{getnstr} and @code{getch}

@example
@verbatiminclude ex_getnstr.scm
@end example

@node Attributes, Windows Tutorial, Input functions, Curses Tutorial
@section Attributes
@cindex Attributes

Attributes can be used to print characters with some special effects.
Attributes, when set prudently, can present information in an easy,
understandable manner.

The following program takes a scheme file as input and prints the file
with comments in bold.  It does so by turning on the @code{A_BOLD}
attribute using @code{attr-on!} when a semicolon is detected, and then
turning of the @code{A_BOLD} attribute using @code{attr-off!} when a
newline is detected.  Have a look.

@example
@verbatiminclude ex_attrib.scm
@end example

One important thing to note is that in this program, @code{addch} is
always passed a normal, un-bolded, character.  Note the line
@example
          (addch stdscr (normal ch))
@end example
But yet, the character printed by @code{addch} may still appear as
bold on the screen.  This is because the character attributes passed
to @code{addch} combine with the character attributes set by
@code{attr-on!}.  If @code{attr-on!} has set the window's default
attributes to bold, that will merge with the attributes passed to
@code{addch}.


The function also introduces the useful function @code{getyx}.  It
returns the coordinates of the present cursor as a list of two
elements.

The above program is really a simple one which doesn't do much.  Along
these lines once could write a more useful program which reads a scheme
file, parses it, and prints it in different colors.

@menu
* The details::
* @code{attr-on!} vs @code{attr-set!}::
* @code{attr-get}::
* @code{chgat} function::
@end menu

@node The details, @code{attr-on!} vs @code{attr-set!}, Attributes, Attributes
@subsection The details
@cindex Attributes

Let's get into more details of attributes.  The functions
@code{attr-on!}, @code{attr-off!}, @code{attr-set!}, and their sister
functions @code{attr-get} etc., can be used to switch attributes on
and off, get attributes, and produce a colorful display.

The functions @code{attr-on!} and @code{attr-off!} take a bit-mask of
attributes and switch them on or off respectively.  The following
video attributes can be passed to these functions.

@table @code
@item A_NORMAL
Normal display (no highlight)
@item A_STANDOUT
Best highlighting mode of the terminal
@item A_UNDERLINE
Underlining
@item A_REVERSE
Reverse video
@item A_BLINK
Blinking
@item A_DIM
Half-bright
@item A_BOLD
Extra bright or bold
@item A_PROTECT
Protected mode
@item A_INVIS
Invisible or blank mode
@item A_ALTCHARSET
Alternate character set
@item A_CHARTEXT
Bit-mask to extract a character
@item A_HORIZONTAL
Unsupported for now and left for future use
@item A_LEFT
Unsupported for now and left for future use
@item A_LOW
Unsupported for now and left for future use
@item A_RIGHT
Unsupported for now and left for future use
@item A_TOP
Unsupported for now and left for future use
@item A_VERTICAL
Unsupported for now and left for future use
@item (color-pair n)
A procedure that returns the bit mask for a color-pair
@end table

Colors are explained in the next sections.

We can @code{logior} any number of attributes to get a combined
effect.  If you wanted the character in window @code{win} to have
reverse video with blinking characters, you can use
@example
(attr-on! win (logior A_REVERSE A_BLINK))
@end example

@node @code{attr-on!} vs @code{attr-set!}, @code{attr-get}, The details, Attributes
@subsection @code{attr-on!} vs @code{attr-set!}
@cindex Attributes, setting

Then what is the difference between @code{attr-on!} and
@code{attr-set!}?  @code{attr-set!} sets the attributes of a window
whereas @code{attr-on!} just switches on the attribute given to it.  So
@code{attr-set!} fully overrides whatever attributes the window
previously had and sets it to the new attribute(s).  Similarly,
@code{attr-off!} just switches off the attributes(s) given to it as an
argument.  This gives us the flexibility of managing attributes
easily.  But, if you use them carelessly, you may lose track of what
attributes the window has and garble the display.  This is especially
true while managing menus with colors and highlighting.  So decide on
a consistent policy and stick to it.  You can always use
@code{standend!} which is equivalent to @code{(attr-set! win A_NORMAL)}
which turns off all attributes and brings you back to normal mode.

@node @code{attr-get}, @code{chgat} function, @code{attr-on!} vs @code{attr-set!}, Attributes
@subsection @code{attr-get}
@cindex Attributes, querying

The function @code{attr-get} gets the current attributes and color
pair of the window.  Though we might not use this as often as the
above functions, this is useful in scanning areas of a screen.  Say we
wanted to do some complex update on the screen and we are not sure
what attribute each character is associated with.  Then this function
can be used with either @code{attr-set!} or @code{attr-on!} to produce the
desired effect.

@node @code{chgat} function,  , @code{attr-get}, Attributes
@subsection @code{chgat} function

The function @code{chgat}, which is short for @emph{change
attributes}, can be used to set attributes for a group of characters
already on the screen without moving the cursor.  It changes the
attributes of a given number of characters starting at the current
cursor location.

You can pass it -1 as the character count to update until the end of
the current line.

The following example changes the attributes of characters from the
current position to the end of the line to reverse video on a window
named @code{win1}.

@example
(chgat win1 -1 A_REVERSE 0)
@end example

The are optional key parameters @code{#:y} and @code{#:x} can be used
with @code{chgat}.

The following example will print a string on the screen.  Then it will
set the first 5 characters of the string to blink and change color to
cyan.

@example
@verbatiminclude ex_blink.scm
@end example

This example also introduces us to the color world of curses.  Colors
will be explained in detail later.  Use 0 for white on black.

Now wait@enddots{}  Did you try running this little script?  Did it work?
Blinking is one of those features that may not be implemented on your
terminal.  As of the moment of this writing, Gnome terminal doesn't do
blinking.  The standard xterm does do blinking, but, it doesn't blink
at the location of the cursor.

@node Windows Tutorial, Colors, Attributes, Curses Tutorial
@section Windows Tutorial

Windows form the most important concept in curses.  You have seen the
standard window @code{stdscr} used in most of the previous examples.
Now to design even a simplest GUI, you need to resort to windows.  The
main reason you may want to use windows is to manipulate parts of the
screen separately, for better efficiency, by updating only the windows
that need to be changed, and for a better design.  I would say the
last reason is the most important in going for windows.  You should
always strive for a better and easy-to-manage design in your programs.
If you are writing big, complex GUIs, this is of pivotal importance
before you start doing anything.

Now, anyone that has worked with a modern GUI has an intuitive
understanding of what a ``window'' is.  You will need to unlearn this
knowledge when programming curses windows.

First off, a curses window doesn't necessarily have any sort of border
or decoration that separates it from the rest of the terminal.  You
can make a curses window and then draw a border on it, but, that is up
to the programmer.

Second, curses windows don't normally overlap.  They are usually
distinct, non-overlapping regions of the screen.

@menu
* The basics::
* Let there be a window::
* Other functions::
* Other border functions::
@end menu

@node The basics, Let there be a window, Windows Tutorial, Windows Tutorial
@subsection The basics
@cindex Windows, creation

A window can be created by calling the function @code{newwin}. It
doesn't draw anything on the screen initially.  It allocates memory
for a structure to manipulate the window and updates the structure with
data regarding the window, like it's size, position, etc.

The function @code{newwin}, like @code{initscr}, returns a
@code{#<window>}.  Just like the @code{stdscr} created by
@code{initscr}, the window created by @code{newwin} can be used in any
procedure that takes a window argument. The window returned by
@code{newwin} needs to remain in scope for as long as the window is to
be used.  If it is garbage collected, the memory associated with the
window will eventually be freed.

The memory associated with a window can be more quickly freed by
explicitly calling @code{delwin}.  It will deallocate the memory
associated with the window structure.  Any further attempts to then
use that window will cause an error.

@node Let there be a window, Other functions, The basics, Windows Tutorial
@subsection Let there be a window

What fun is it if a window is created and we can't see it?  So the fun
part begins by displaying the window.  The functions @code{box} and
@code{border} can be used to draw a border around the window.  Let's
explore these functions in more detail in this example.

This example isn't meant as a practical example of what windows are
good for.  It just shows how to make, draw, erase, and destroy them.

@example
@verbatiminclude ex_window.scm
@end example

Don't scream.  I know it is a big example.  But there are some
important things to explain here.  This program creates a rectangular
window that can be moved with left, right, up, and down arrow keys.
It repeatedly creates and destroys windows as a user presses a key.
Don't go beyond the screen limits.  Checking for limits is left as an
exercise for the reader.  Let's dissect it line by line.

The @code{create-newwin} function creates a window with @code{newwin}
and draws a box around it with @code{box}.  For the horizontal lines in
the box, I chose the special drawing character @code{acs-hline}.  The
vertical lines are the special drawing character @code{acs-vline}.
For the corners of the box, the @code{box} procedure will use a guess
of the best available corners for the terminal.

Most terminals will have special box drawing characters available.
The procedure @code{acs-hline} and @code{acs-vline} will return these
special drawing characters.  If the terminal you are using does not
have box drawing characters available, @code{acs-hline} and
@code{acs-vline} will return the hyphen ``-'' and the vertical bar
``|''.

The procedure @code{destroy-win} first erases the window from the
screen by painting a border of blanks and then calling @code{delwin}
to deallocate memory related to it.  Depending on the key the user
presses, @code{startx} and @code{starty} are changed, and a new window
is created.

In the @code{destroy-win}, as you can see, I used @code{border}
instead of @code{box}.  The reason is this:  @code{border} draws a
border around the window and the characters given to it as the four
corners and the four lines.  To put it clearly, if you called border
as below:

@example
(border win
        (normal #\|)
        (normal #\|)
        (normal #\-)
        (normal #\-)
        (normal #\+)
        (normal #\+)
        (normal #\+)
        (normal #\+))
@end example
it produces something like this
@verbatim
   +-----+
   |     |
   |     |
   |     |
   +-----+
@end verbatim

It wouldn't have been sufficient to use @code{(box win (normal #\sp)
(normal #\sp))} to erase the box, because the @code{box} procedure
still would have drawn the four corners of the box.

@node Other functions, Other border functions, Let there be a window, Windows Tutorial
@subsection Other functions

You can also see in the above examples that I have used the procedures
@code{cols}, and @code{lines}.  These procedures return the size of
the @code{stdscr}.

The function @code{getch} as usual gets the key from the keyboard, and
then the @code{cond} expression acts on the key pressed.  This type of
@code{cond} expression is very common in any GUI-based program.

@node Other border functions,  , Other functions, Windows Tutorial
@subsection Other border functions

The @code{box} and @code{border} procedures are useful, but, they only
draw borders around the outside of windows.  If you want to draw lines
on the screen is other locations than the border of windows, you can
use the @code{hline} and @code{vline} procedures.

The following little program shows how to draw a box at any location.
To draw a box, it needs to draw four corners, two horizontal lines,
and two vertical lines.  It uses @code{hline} and @code{vline}.  These
two functions are simple.  They create a horizontal or vertical line
of the specified length at the specified position.  The program uses
more of the special drawing characters like @code{(acs-urcorner)},
which is the upper-right corner of a box.

@example
@verbatiminclude ex_hline.scm
@end example

@node Colors, Interfacing with the keyboard, Windows Tutorial, Curses Tutorial
@section Colors

@menu
* The basics of color::
* Changing color definitions::
@end menu

@node The basics of color, Changing color definitions, Colors, Colors
@subsection The basics of color
@cindex Colors
@cindex Colors, initialization
Life seems dull with no colors.  Curses has a nice mechanism to handle
colors.  Let's get into the thick of things with a small program.

@example
@verbatiminclude ex_color.scm
@end example

As you can see, to start using color, you should first call
@code{start-color!}.  After that you can use color capabilities of your
terminal.  To find out whether a terminal has color capabilities or
not, you can use @code{has-colors?}, which returns @code{#f} if the
terminal does not support color.

@findex color-pair
@cindex Color pairs

Curses initializes all the color support for the terminal when
@code{start-color!} is called.  Usually, a color terminal will have at
least eight colors available that can be accessed by constants like
@code{COLOR_BLACK}, etc.  Now to actually start using colors, you
have to define pairs.  Colors are always used in pairs.  That means
you have to use the function @code{init-pair!} to define the foreground
and background for the pair number you give.  After that, that pair
number can be used as a normal attribute with the @code{color-pair}
procedure.  This may seem to be cumbersome at first.

The following colors are defined.  You can use these as parameters for
the various color functions.
@enumerate
@item
COLOR_BLACK
@item
COLOR_RED
@item
COLOR_GREEN
@item
COLOR_YELLOW
@item
COLOR_BLUE
@item
COLOR_MAGENTA
@item
COLOR_CYAN
@item
COLOR_WHITE
@end enumerate

@node Changing color definitions,  , The basics of color, Colors
@subsection Changing color definitions
@cindex Colors, modifying
@cindex Terminal capabilities, color

Most terminals don't support defining new colors or changing the
colors that already exist.  For those terminals that do, the function
@code{init-color!} can be used to change the definition of colors by
adjusting the amount of red, green, and blue in each.  To set the red
to a darker red, you could use this function
@example
;; Param 1: color name
;; Param 2, 3, 4; RGB content, min=0 max=1000
(init-color! COLOR_RED 300 0 0)
@end example

If your terminal cannot change the color definitions, the procedure
will throw and error.  The function @code{can-change-color?} can be
used to find out whether that terminal has the capability of changing
color content or not.  The RGB content is scaled from 0 to 1000.
Initially, red is likely defined with content 680 (r), 0 (g), 0 (b).

The functions @code{color-content} and @code{pair-content} can be used
to find the color content of a given color and foreground/background
combination of a color pair.

@node Interfacing with the keyboard, Interfacing with the mouse, Colors, Curses Tutorial
@section Interfacing with the keyboard

@menu
* The basics of keys::
* A simple key usage example::
@end menu

@node The basics of keys, A simple key usage example, Interfacing with the keyboard, Interfacing with the keyboard
@subsection The basics of keys
@cindex Function keys

No GUI is complete without a strong user interface and to interact
with the user, a curses program should be sensitive to key presses or
mouse actions done by the user.  Let's deal with keys first.

As you have seen in almost all of the above examples, it's very easy
to get key input from the user.  A simple way of getting key presses
is the @code{getch} procedure.  The @code{cbreak!} mode should be
enabled to read keys when you are interested in reading individual key
hits rather than complete lines of text (which usually end with a
@key{CR}).  @code{keypad!} should be enabled to get the function
keys, arrow keys and so on.

@code{getch} returns a character if the key pressed maps to a standard
character or it returns an integer code for those keys that don't map
to characters, such as @key{PAGE UP} or @key{DELETE}.  This integer
code which can be matched with the @code{KEY_} constants.  For
example, if the user presses @key{F1}, the integer returned is 265.
The procedure @code{(key-f 1)} returns 265.

For example, if you call @code{getch} like this
@example
(let ((x (getch win)))
@dots{}
@end example
@code{getch} will wait for the user to press a key, (unless you
specified a timeout), and when the user presses a key, the
corresponding character or integer is returned.  If it is an integer,
then you can check the value returned with the @code{KEY_} constants
or the result of the function key procedure @code{key-f}.

The following code piece will do that job
@example
(let ((ch (getch win)))
    (if (eqv? ch KEY_LEFT)
        (addstr win "Left arrow is pressed")))
@end example

Let's write a small program which creates a menu that can be navigated
by up and down arrows.

@node A simple key usage example,  , The basics of keys, Interfacing with the keyboard
@subsection A simple key usage example

@example
@verbatiminclude ex_menu.scm
@end example

@node Interfacing with the mouse, Panels Library, Interfacing with the keyboard, Curses Tutorial
@section Interfacing with the mouse

Now that you have seen how to get keys, let's do the same thing from
the mouse.  Usually each UI allows the user to interact with both
keyboard and mouse.

@menu
* The basics of the mouse::
* Getting the events::
* Miscellaneous functions::
@end menu

@node The basics of the mouse, Getting the events, Interfacing with the mouse, Interfacing with the mouse
@subsection The basics of the mouse

Before you do anything else, the events you want to receive have to be
enabled with @code{mousemask}.  You pass it a bit mask of events you
would like to listen.  By default, all the events are turned off.  The
bit mask @code{ALL_MOUSE_EVENTS} can be used to get all the events.

For current technology, the following events are of use.
@multitable {*XXXXXXXXXXXXXXXXXXXXXX*} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}
@headitem Name              @tab Description

@item @code{BUTTON1_PRESSED}
@tab mouse button 1 down
@item @code{BUTTON1_RELEASED}
@tab mouse button 1 up
@item @code{BUTTON1_CLICKED}
@tab mouse button 1 clicked
@item @code{BUTTON1_DOUBLE_CLICKED}
@tab mouse button 1 double clicked
@item @code{BUTTON2_PRESSED}
@tab mouse button 2 down
@item @code{BUTTON2_RELEASED}
@tab mouse button 2 up
@item @code{BUTTON2_CLICKED}
@tab mouse button 2 clicked
@item @code{BUTTON2_DOUBLE_CLICKED}
@tab mouse button 2 double clicked
@item @code{BUTTON_SHIFT}
@tab shift was down during button state change
@item @code{BUTTON_CTRL}
@tab control was down during button state change
@item @code{BUTTON_ALT}
@tab alt was down during button state change
@item @code{ALL_MOUSE_EVENTS}
@tab report all button state changes
@item @code{REPORT_MOUSE_POSITION}
@tab report mouse movement
@end multitable

There similar constants for mouse button #3 and #4.

There are some important things to note.
@enumerate
@item
Mouse buttons 1, 2, and 3 may be right, center, and left respectively, instead of
right, left, and center.
@item
The @code{BUTTON_SHIFT}, @code{BUTTON_ALT}, and
@code{BUTTON_CTRL} codes will probably not work, as they will
probably be intercepted by the window manager.
@item
The mouse driver will not send both a click/release pair and a pressed
message.
@end enumerate


@node Getting the events, Miscellaneous functions, The basics of the mouse, Interfacing with the mouse
@subsection Getting the events

Once a class of mouse events have been enabled, @code{getch} and
friends return @code{KEY_MOUSE} every time some mouse event
happens.  Then, the mouse event can be retrieved with @code{getmouse}.

@code{getmouse} returns a list of five elements: id, x, y, z, and
flags.  The flags contain information about mouse button events.

Schematically, decoding mouse events could look like this.  (Note that
I've used some of the srfi-1 list functions in this example.)

@example
(set! c (getch win))
(if (eqv? c KEY_MOUSE)
    (let* ((m (getmouse))
           (mouse-x (second m))
           (mouse-y (third m))
           (mouse-flag (fifth m)))
       (cond
        ((logtest BUTTON1_PRESSED mouse-flag)
         ; do button1-pressed response here
        )
        ((logtest BUTTON1_RELEASED mouse-flag)
         ; do button1-released response here
        ))))
@end example

@node Miscellaneous functions,  , Getting the events, Interfacing with the mouse
@subsection Miscellaneous functions

The function @code{mouse-trafo} can be used to convert mouse
coordinates to screen relative coordinates.

The @code{mouseinterval} function sets the maximum time (in
thousandths of a second) that can elapse between press and release
events in order for them to be recognized as a click. The default is
one-fifth of a second.

@node Panels Library, Menu Library, Interfacing with the mouse, Curses Tutorial
@section Panels Library

Curses was originally build around the idea of having tiled text
windows, where they did not overlap.  The API is not set up to do the
bookkeeping for overlapping windows.

Now that you are proficient in curses, you wanted to do some thing
big. You created a lot of overlapping windows to give a professional
windows-type look. Unfortunately, it soon becomes difficult to manage
these. The multiple refreshes, updates plunge you into a
nightmare. The overlapping windows create blotches, whenever you
forget to refresh the windows in the proper order.

Don't despair. There's an elegant solution provided in panels
library.

When your interface design is such that windows may dive deeper into
the visibility stack or pop to the top at runtime, the resulting
book-keeping can be tedious and difficult to get right. Hence the
panels library.

If you have lot of overlapping windows, then panels library is the way
to go.  It obviates the need of doing series of @code{noutrefresh},
@code{doupdate} and relieves the burden of doing it correctly (bottom
up). The library maintains information about the order of windows,
their overlapping and update the screen properly. So why wait? Let's
take a close peek into panels.

@menu
* Panels Basics::
* Compiling With the Panels Library::
* Moving and Resizing Panels::
@end menu

@node Panels Basics, Compiling With the Panels Library, Panels Library, Panels Library
@subsection Panels Basics

The @code{#<panel>} object is a window that is implicitly treated as
part of a deck including all other panel objects. The deck is treated
as a stack with the top panel being completely visible and the other
panels may or may not be obscured according to their positions. So the
basic idea is to create a stack of overlapping panels and use panels
library to display them correctly. There is a function similar to
@code{refresh} which, when called , displays panels in the correct
order. Functions are provided to hide or show panels, move panels,
change its size etc.. The overlapping problem is managed by the panels
library during all the calls to these functions.

The general flow of a panel program goes like this:

@enumerate
@item
Create the windows (with @code{newwin}) to be attached to the panels.

@item
Create panels with the chosen visibility order. Stack them up
according to the desired visibility. The function @code{new-panel} is
used to create panels.

@item
Call @code{update-panels} to write the panels to the virtual screen in
correct visibility order. Do a @code{doupdate} to show it on the
screen.

@item
Manipulate the panels with @code{show-panel}, @code{hide-panel},
@code{move-panel} etc.  Make use of helper functions like
@code{panel-hidden} and @code{panel-window}.

@item
When you are done with the panel use @code{del-panel} to delete the
panel.

@end enumerate

Let's make the concepts clear, with some programs. The following is a simple
program which creates 3 overlapping panels and shows them on the screen.

@node Compiling With the Panels Library, Moving and Resizing Panels, Panels Basics, Panels Library
@subsection Compiling With the Panels Library

To use panels library functions, you have to use the module
@code{(ncurses panel)}.

@example
@include ex_panel.scm
@end example

As you can see, above program follows a simple flow. The windows are
created with @code{newwin} and then they are attached to panels with
@code{new-panel}. As we attach one panel after another, the stack of
panels gets updated.  To put them on screen @code{update-panels} and
@code{doupdate} are called.

The panels can be brought to the front with @code{top-panel} or pushed
to the back with @code{bottom-panel}.  They can be removed with
@code{hide-panel}, and then unhidden with @code{show-panel}.

@node Moving and Resizing Panels,  , Compiling With the Panels Library, Panels Library
@subsection Moving and Resizing Panels
@cindex Windows, moving

The procedure @code{move-panel} can be used to move a panel to the
desired location. It does not change the position of the panel in the
stack. Make sure that you use @code{move-panel} instead @code{mvwin}
on the window associated with the panel.

Resizing a panel is slightly complex. There is no straight forward
function just to resize the window associated with a panel. A solution
to resize a panel is to create a new window with the desired sizes,
change the window associated with the panel using
@code{replace-panel!}. Don't forget to delete the old window. The
window associated with a panel can be found by using the function
@code{panel-window}.


@node Menu Library, Forms Library, Panels Library, Curses Tutorial
@section Menu Library

The menus library provides a nice extension to basic curses, through
which you can create menus. It provides a set of functions to create
menus. But they have to be customized to give a nicer look, with
colors etc. Let's get into the details.

A menu is a screen display that assists the user to choose some subset
of a given set of items. To put it simple, a menu is a collection of
items from which one or more items can be chosen. Some readers might
not be aware of multiple item selection capability. The menu library
provides functionality to write menus from which the user can chose
more than one item as the preferred choice. This is dealt with in a
later section. Now it is time for some rudiments.

@menu
* Menu Basics::
* Menu Driver::
* Menu Windows::
* Scrolling Menus::
@end menu

@node Menu Basics, Menu Driver, Menu Library, Menu Library
@subsection Menu basics

To create menus, you first create items, and then post the menu to the
display. After that, all the processing of user responses is done in
an elegant function @code{menu-driver} which is the work horse of any
menu program.

The general flow of control of a menu program looks like this.

@enumerate
@item
Initialize curses

@item
Create items using @code{new-item}. You can specify a name and
description for the items.

@item
Create the menu with @code{new-menu} by specifying the items with
which it is to be attached.

@item
Post the menu with @code{menu-post} and refresh the screen.

@item
Process the user requests with a loop and do necessary updates to menu
with @code{menu-driver}.

@item
Unpost the menu with @code{menu-unpost}.

@item
End curses.

@end enumerate

Let's see a program which prints a simple menu and updates the current
selection with up, down arrows.

To use menu library functions, you have to use the module @code{(ncurses
menu)}.

@example
@include ex_menu2.scm
@end example

This program demonstrates the basic concepts involved in creating a
menu using menus library. First we create the items using
@code{new-item} and then attach them to the menu with @code{new-menu}
function. After posting the menu and refreshing the screen, the main
processing loop starts. It reads user input and takes corresponding
action. The function @code{menu-driver} is the main work horse of the
menu system. The second parameter to this function tells what's to be
done with the menu. According to the parameter, @code{menu-driver}
does the corresponding task. The value can be either a menu
navigational request, an ASCII character, or a @code{KEY_MOUSE}
special key associated with a mouse event.

The menu_driver accepts following navigational requests.
@table @code
@item REQ_LEFT_ITEM
Move left to an item.
@item REQ_RIGHT_ITEM
Move right to an item.
@item REQ_UP_ITEM
Move up to an item.
@item REQ_DOWN_ITEM
Move down to an item.
@item REQ_SCR_ULINE
Scroll up a line.
@item REQ_SCR_DLINE
Scroll down a line.
@item REQ_SCR_DPAGE
Scroll down a page.
@item REQ_SCR_UPAGE
Scroll up a page.
@item REQ_FIRST_ITEM
Move to the first item.
@item REQ_LAST_ITEM
Move to the last item.
@item REQ_NEXT_ITEM
Move to the next item.
@item REQ_PREV_ITEM
Move to the previous item.
@item REQ_TOGGLE_ITEM
Select/deselect an item.
@item REQ_CLEAR_PATTERN
Clear the menu pattern buffer.
@item REQ_BACK_PATTERN
Delete the previous character from the pattern buffer.
@item REQ_NEXT_MATCH
Move to the next item matching the pattern match.
@item REQ_PREV_MATCH
Move to the previous item matching the pattern match.
@end table

Don't get overwhelmed by the number of options. We will see them
slowly one after another. The options of interest in this example are
@code{REQ_UP_ITEM} and @code{REQ_DOWN_ITEM}. These two options when
passed to menu_driver, menu driver updates the current item to one
item up or down respectively.

@node Menu Driver, Menu Windows, Menu Basics, Menu Library
@subsection Menu Driver: The work horse of the menu system

As you have seen in the above example, @code{menu-driver} plays an
important role in updating the menu. It is very important to
understand various options it takes and what they do. As explained
above, the second parameter to @code{menu-driver} can be either a
navigational request, a printable character or a @code{KEY_MOUSE}
key. Let's dissect the different navigational requests.

@table @code
@item REQ_LEFT_ITEM and REQ_RIGHT_ITEM

A menu can be displayed with multiple columns for more than one item.
This can be done by using the @code{menu-format} function. When a
multicolumnar menu is displayed these requests cause the menu driver
to move the current selection to left or right.

@item REQ_UP_ITEM and REQ_DOWN_ITEM

These two options you have seen in the above example. These options
when given, makes the @code{menu-driver} to move the current selection
to an item up or down.

@item REQ_SCR_* options

The four options @code{REQ_SCR_ULINE}, @code{REQ_SCR_DLINE},
@code{REQ_SCR_DPAGE}, @code{REQ_SCR_UPAGE} are related to
scrolling. If all the items in the menu cannot be displayed in the
menu sub window, then the menu is scrollable.  These requests can be
given to the @code{menu-driver} to do the scrolling either one line
up, down or one page down or up respectively.

@item REQ_FIRST_ITEM, REQ_LAST_ITEM, REQ_NEXT_ITEM and REQ_PREV_ITEM

Easy enough.

@item REQ_TOGGLE_ITEM

This request when given, toggles the present selection. This option is
to be used only in a multivalued menu. So to use this request the
option @code{O_ONEVALUE} must be off. This option can be made off or
on with @code{set_menu_opts}.

@item Pattern Requests

Every menu has an associated pattern buffer, which is used to find the
nearest match to the ASCII characters entered by the user. Whenever
ASCII characters are given to menu_driver, it puts in to the pattern
buffer. It also tries to find the nearest match to the pattern in the
items list and moves current selection to that item. The request
@code{REQ_CLEAR_PATTERN} clears the pattern buffer. The request
@code{REQ_BACK_PATTERN} deletes the previous character in the pattern
buffer. In case the pattern matches more than one item then the
matched items can be cycled through @code{REQ_NEXT_MATCH} and
@code{REQ_PREV_MATCH} which move the current selection to the next and
previous matches respectively.

@item Mouse Requests

In case of @code{KEY_MOUSE} requests, according to the mouse position
an action is taken accordingly. The action to be taken is explained in
the man page as, If the second argument is the @code{KEY_MOUSE}
special key, the associated mouse event is translated into one of the
above pre-defined requests.  Currently only clicks in the user window
(e.g. inside the menu display area or the decoration window) are
handled. If you click above the display region of the menu, a
@code{REQ_SCR_ULINE} is generated, if you doubleclick a
@code{REQ_SCR_UPAGE} is generated and if you tripleclick a
@code{REQ_FIRST_ITEM} is generated.  If you click below the display
region of the menu, a REQ_SCR_DLINE is generated, if you doubleclick a
@code{REQ_SCR_DPAGE} is generated and if you tripleclick a
@code{REQ_LAST_ITEM} is generated. If you click at an item inside the
display area of the menu, the menu cursor is positioned to that item.

@end table

Each of the above requests will be explained in the following lines with
several examples whenever appropriate.

@node Menu Windows, Scrolling Menus, Menu Driver, Menu Library
@subsection Menu Windows

Every menu created is associated with a window and a subwindow. The
menu window displays any title or border associated with the menu. The
menu subwindow displays the menu items currently available for
selection. But we didn't specify any window or sub window in the
simple example. When a window is not specified, @code{stdscr} is taken
as the main window, and then menu system calculates the subwindow
size required for the display of items. Then items are displayed in
the calculated sub window. So let's play with these windows and
display a menu with a border and a title.

@example
@include ex_menu3.scm
@end example

This example creates a menu with a title, border, a fancy line
separating title and the items. As you can see, in order to attach a
window to a menu the function @code{set-menu-win!} has to be used. Then
we attach the sub window also. This displays the items in the sub
window. You can also set the mark string which gets displayed to the
left of the selected item with @code{set-menu-mark!}.

@node Scrolling Menus,  , Menu Windows, Menu Library
@subsection Scrolling Menus

If the subwindow given for a window is not big enough to show all the
items, then the menu will be scrollable. When you are on the last item
in the present list, if you send @code{REQ_DOWN_ITEM}, it gets
translated into @code{REQ_SCR_DLINE} and the menu scrolls by one
item. You can manually give @code{REQ_SCR_} operations to do
scrolling.


@node Forms Library,  , Menu Library, Curses Tutorial
@section Forms Library

Well, if you have seen those forms on web pages that take input from
users and do various kinds of things, you might be wondering how one
would create such form in a text mode display.  It's quite difficult
to write those nifty forms in plain ncurses.  The forms library tries
to provide a basic framework to build and maintain forms with ease.
It has lots of features that manage validation, dynamic expression of
fields, and so on.  Let's see it in full flow.

A form is a collection of fields. Each field can be either a label
(static text) or a data-entry location.  The forms library also
provides functions to divide forms into multiple pages.

@menu
* The Basics (Forms)::
* A Form Example::
* Making it useful::
* Playing with fields::
* Field Display Attributes::
* Field Option Bits::
* Field Status::
* Variable-Sized Fields::
* Form Windows::
* Field Validation::
* The Form Driver::
@end menu

@node  The Basics (Forms), A Form Example, Forms Library, Forms Library
@subsection The Basics

Forms are created in much the same way as menus.  First, the fields
related to the form are created with @code{new-field}.  You can set
options for the fields, so that they can be displayed with some fancy
attributes, validated before the field looses focus, etc.  Then the
fields are attached to the form.  After this, the form can be posted
to display and is ready to receive inputs.  Along similar lines to
@code{menu-driver}, the form is manipulated with @code{form-driver}.
We can send requests to @code{form-driver} to move focus to a certain
field, move the cursor to the end of the field, and so on.  After the
user enters the values in the fields and validation is done, the form
can be unposted and the memory allocated can be freed.

The general flow of control of a form program looks like this

@enumerate
@item
Initialize curses
@item
Create fields using @code{new-field}.  You can specify the height and
width of the field, and its position on the form.
@item
Create the forms with @code{new-form} by specifying the fields to be
attached.
@item
Post the form with @code{form-post} and refresh the screen.
@item
Process the user requests with a loop and do necessary updates to the
form with @code{form-driver}.
@item
Unpost the menu with @code{form-unpost}
@item
If desired, explicitly free the memory allocated to menu with
@code{free-form}.
@item
If desired, explicitly free the memory allocated to menu item with
@code{free-field}.
@item
End curses.
@end enumerate

The forms library is similar to the menu library.  The following
examples will explore various aspects of form processing.  Let's stat
the journey with a simple example first.

@node A Form Example, Making it useful, The Basics (Forms), Forms Library
@subsection A Form Example

To use form library functions, you have to include @code{(ncurses
form)}.

@example
@verbatiminclude ex_form.scm
@end example

The above example is pretty straightforward.  It creates two fields
with @code{new-field}.  The procedure @code{new-field} takes height,
width startx, starty, the number of off-screen rows, and number of
additional working buffers.  The fifth argument number of off-screen
rows specified how much of the field to be shown.  If it is zero, the
entire field is always displayed; otherwise, the form will be
scrollable when the user accesses undisplayed part of the field.  The
forms library allocates one buffer per field to store the data which
the user enters.  Using the last parameter to @code{new-field} we can
specify it to allocate some additional buffers.  These can be used for
any purpose you like.

After creating the fields, the background attribute of both of them is
set to an underscore with @code{set-field-back!}.  The @code{AUTOSKIP}
option is turned off using @code{field-opts-off!}.  If this option is
turned of, focus will move to the next field in the form once the
active field is filled up completely.

After attaching the fields to the form, it is posted.  Here on, user
inputs are processed in the loop, by making corresponding request to
@code{form-driver}.  The details of all the request to
@code{form-driver} are explained later.

@node  Making it useful, Playing with fields, A Form Example, Forms Library
@subsection Making it useful

The previous example does create a form and allow one to move between
the fields, but, it doesn't perform the useful function of allowing
the program to fetch the contents of those fields.  Also, the basic
editing features like @key{BS} and @key{DELETE} are not connected.

To make it useful, it needs a couple of important
changes.  First, it passes more of the important editing commands like
@key{BS} and @key{DELETE} to the form driver for processing.  Second,
it fetches the final content of the fields as one would normally do in
a form application.

A more complete editing loop might look like this
@example
;; Loop through to get user requests
(let loop ((ch (getch win)))
  (if (not (eqv? ch (key-f 1)))
      (begin
        (cond
         ((eqv? ch KEY_DOWN)
          (begin
            ;; Go to the end of the next field
            (form-driver my-form REQ_NEXT_FIELD)
            (form-driver my-form REQ_END_LINE)))
         ((eqv? ch KEY_UP)
          (begin
            ;; Go to the end of the previous field
            (form-driver my-form REQ_PREV_FIELD)
            (form-driver my-form REQ_END_LINE)))
         ((eqv? ch KEY_LEFT)
          (form-driver my-form REQ_PREV_CHAR))
         ((eqv? ch KEY_RIGHT)
          (form-driver my-form REQ_NEXT_CHAR))
         ((eqv? ch KEY_DC)
          (form-driver my-form REQ_DEL_CHAR))
         ((eqv? ch KEY_BACKSPACE)
          (form-driver my-form REQ_DEL_PREV))
         (else
          (form-driver my-form ch)))
        (loop (getch win)))))
@end example

And, gathering the contents of the form can be accomplished like this:

@example
;; Move the cursor to ensure that the last characters typed by the
;; user get committed to the field buffer.
(form-driver my-form REQ_LAST_FIELD)
;; Unpost the form
(unpost-form my-form)

;; Store the contents of the field
(let ((result1 (field-buffer (first field) 0))
      (result2 (field-buffer (second field) 0)))
  (endwin)
  (display (string-append "You typed " result1 " and " result2))
  (newline))
@end example

@node Playing with fields, Field Display Attributes, Making it useful, Forms Library
@subsection Playing with fields

Each form field is associated with lots of attributes.  They can be
manipulated to get the required effect.

@subsubsection Fetching Size and Location of Field

The parameters we have given at the time of creation of a field can be
retrieved with @code{field-info}.

@example
(field-info field)
@end example

The procedure @code{field-info} takes a field and returns a list:
height, width, top, left, offscreen, and number of buffers.

The location of the field can be moved to a different position with
@code{move-field}, but, only if this field hasn't become part of a
form.  (This function is thus mostly useless.)

@example
(move-field field top left)
@end example


The justification to be done for the field can be fixed using the
function @code{set-field-just!}

@example
(set-field-just! field justification)
@end example

The justification mode value is the either @code{NO_JUSTIFICATION},
@code{JUSTIFY_RIGHT}, @code{JUSTIFY_LEFT}, or @code{JUSTIFY_CENTER}.

The procedure @code{field-just} returns the justification mode.

@node Field Display Attributes, Field Option Bits, Playing with fields, Forms Library
@subsection Field Display Attributes

As you have seen, in the above example, display attributes for the
fields can be set with @code{set-field-fore!} and
@code{set-field-back!}.  These functions set foreground and background
attributes of the fields.  You can also specify a pad character that
will be filled in the unfilled portion of the field.  The pad
character is set with a call to @code{set-field-pad!}.  Default pad
value is space.  The functions @code{field-fore} , @code{field-back},
and @code{field-pad} can be used to query the present foreground
background attributes and pad character for the field.

Though the functions seem quite simple, using colors with
@code{set-field-fore!} may be frustrating in the beginning.  Let me
first explain about foreground and background attributes of a field.
The foreground attribute is associated with the character.  That means
a character in the field is printed with the attribute you have set
with @code{set-field-fore!}.  Background attribute is the attribute
used to fill background of field, whether any character is there or
not.  So what about colors?  Since colors are always defined in pairs,
what is the right way to display colored fields?  Here's an example
clarifying color attributes.

@example
@verbatiminclude ex_form2.scm
@end example

Play with the color pairs and try to understand the foreground and
background attributes.  Color pair 1 is used for the character that
have been typed into the form, and color pair 2 is used for the empty
spaces in the form.

@node  Field Option Bits, Field Status, Field Display Attributes, Forms Library
@subsection Field Option Bits

There is also a large collection of field option bits you can set to
control various aspects of forms processing.  You can manipulate them
with the procedures @code{set-field-opts!}, @code{field-opts-on!},
@code{field-opts-off!}, and @code{field-opts}.

The function @code{set-field-opts!} can be used to directly set
attributes of a field or you can chose to switch a few attributes on
and off with @code{field-opts-on!} and @code{field-opts-off!}.  You can
query the attributes of a field with @code{field-opts}.  The following
is a list of available options.  By default, all options are on.

@table @code

@item O_VISIBLE

Controls whether the field is visible on the screen.  Can be used
during form processing to hide or pop up fields depending on the value
of parent fields.

@item O_ACTIVE

Controls whether the field is active during forms processing
(i.e. visited by form navigation keys).  Can be used to make labels or
derived fields with buffer values alterable by the forms application,
not the user.

@item O_PUBLIC

Controls whether data is displayed during field entry.  If this option
is turned off on a field, the library will accept and edit data in
that field, but it will not be displayed and the visible field cursor
will not move.  You can turn off the @code{O_PUBLIC} bit to define
password fields.

@item O_EDIT

Controls whether the field's data can be modified.  When this option
is off, all editing requests except @code{REQ_PREV_CHOICE} and
@code{REQ_NEXT_CHOICE} will fail.  Such read-only fields may be useful
for help messages.

@item O_WRAP

Controls word-wrapping in multiline fields.  Normally, when any
character of a (blank-separated) word reaches the end of the current
line, the entire word is wrapped to the next line (assuming there is
one).  When this option is off, the word will be split across the line
break.

@item O_BLANK

Controls field blanking.  When this option is on, entering a character
at the first field position erases the entire field (except for the
just-entered character).

@item O_AUTOSKIP

Controls automatic skip to next field when this one fills.  Normally,
when the forms user tries to type more data into a field than will
fit, the editing location jumps to the next field.  When this option
is off, the user's cursor will hang at the end of the field.  This
option is ignored in dynamic fields that have not reached their size
limit.

@item O_NULLOK

Controls whether validation is applied to blank fields.  Normally, it
is not; the user can leave a field blank without invoking the usual
validation check on exit.  If this option is off on a field, exit from
it will invoke a validation check.

@item O_PASSOK

Controls whether validation occurs on every exit, or only after the
field is modified.  Normally the latter is true.  Setting
@code{O_PASSOK} may be useful if your field's validation function may
change during forms processing.

@item O_STATIC

Controls whether the field is fixed to its initial dimensions.  If you
turn this off, the field becomes dynamic and will stretch to fit
entered data.

@end table

A field's options cannot be changed while the field is currently
selected.  However, options may be changed on posted fields that are
not current.

The option values are bit-masks and can be composed with @code{logior}
in the obvious way.  You have seen the usage of watching off
@code{O_AUTOSKIP} option.  The following example clarified usage of
some more options.  One field is a constant, uneditable field, that
you cannot move to by using the arrow keys.  The other field is a
password-like field where the characters are hidden from view.

@example
#!/usr/local/bin/guile
!#

(use-modules (srfi srfi-1)
             (ncurses curses)
             (ncurses form))

;; Constants
(define STARTX 15)
(define STARTY 4)
(define WIDTH 25)
(define N_FIELDS 2)

;; Initialize curses
(define stdscr (initscr))
(cbreak!)
(noecho!)
(keypad! stdscr #t)

;; Initialize the fields
(define field (map-in-order
               (lambda (y)
                 (new-field 1
                            WIDTH
                            (+ (* y 2) STARTY)
                            STARTX
                            0
                            0))
               (iota N_FIELDS)))

;; Set field options
(set-field-back! (first field) A_UNDERLINE)
;; Don't go to the next field when this field is filled up

;; This field is a static label
(field-opts-off! (first field) O_ACTIVE)

;; This field is like a password field
(field-opts-off! (second field) O_PUBLIC)
(field-opts-off! (second field) O_AUTOSKIP)

;; Create the new form and post it
(define my-form (new-form field))
(post-form my-form)
(refresh)

(set-field-just! (first field) JUSTIFY_CENTER)
(set-field-buffer! (first field) 0 "This is a static field")

(addstr "Field 1:" #:y STARTY #:x (- STARTX 10))
(addstr "Field 2:" #:y (+ STARTY 2) #:x (- STARTX 10))
(refresh)

;; Loop through to get user requests
(let loop ((ch (getch)))
  (if (not (eqv? ch (key-f 1)))
      (cond
       ((eqv? ch KEY_DOWN)
        (begin
          ;; Go to the end of the next field
          (form-driver my-form REQ_NEXT_FIELD)
          (form-driver my-form REQ_END_LINE)
          (loop (getch))))
       ((eqv? ch KEY_UP)
        (begin
          ;; Go to the end of the previous field
          (form-driver my-form REQ_PREV_FIELD)
          (form-driver my-form REQ_END_LINE)
          (loop (getch))))
       (else
        (begin
          ;; Print any normal character
          (form-driver my-form ch)
          (loop (getch)))))))

;; Unpost the form
(unpost-form my-form)

(endwin)
@end example

@node  Field Status, Variable-Sized Fields, Field Option Bits, Forms Library
@subsection Field Status

The field status specifies whether the field has been edited.  It is
initially @code{#f} and when the user enters something and the data
buffer gets modified, it becomes @code{#t}.  So a field's status can
be queried to find out if it has been modified or not.

The two procedures that work with field status are
@code{set-field-status!} and @code{field-status?}.  The procedure
@code{field-status?} returns the current state, and
@code{set-field-status!} can be used to set the state.

@node  Variable-Sized Fields, Form Windows, Field Status, Forms Library
@subsection Variable-Sized Fields

If you want a dynamically changing field with variable width, this is
the feature you want to put to full use.  This will allow the user to
enter more data than the original size of the field and let the field
grow.  According to the field orientation it will scroll horizontally
or vertically to incorporate the new data.

To make a field dynamically growable, the option @code{O_STATIC}
should be turned off.  This can be done with

@example
(field-opts-off! field O_STATIC)
@end example

It is usually not advisable to allow a field to grow infinitely.. You
can set a maximum limit to the growth of the field with
@code{set-max-field}.

The field info for a dynamically growable field can be retrieved with
the procedure @code{dynamic-field-info}.

Recall the library routine @code{new-field}; a new field created with
height set to one will be defined to a one line field.  A new field
created with height greater than one will be defined to be a
multi-line field.

A one line field with @code{O_STATIC} turned off (dynamically
growable) will contain a single fixed row, but, the number of columns
can increase if the user enters more data than the initial field will
hole.  The number of columns displayed will remain fixed and the
additional data will scroll horizontally.

A multiline field with @code{O_STATIC} turned off (dynamically
growable) will contain a fixed number of columns, but, the number of
rows can increase if the user enters more data than the initial field
will hold.  The number of rows displayed will remain fixed and the
additional data will scroll vertically.

@node  Form Windows, Field Validation, Variable-Sized Fields, Forms Library
@subsection Form Windows

The form windows concept is pretty much similar to menu windows.
Every form is associated with a main window and a subwindow.  The form
main window displays any title or border associated or whatever the
user wishes.  The subwindow contains all the fields and displays them
according to their position.  This gives the flexibility of
manipulating fancy form  displays easily.

Since this pretty similar to menu windows, I am providing a very
similar example.

@example

#!/usr/local/bin/guile
!#

(use-modules (srfi srfi-1)
             (ncurses curses)
             (ncurses form))

;; Helper procedure to center a text
(define (print-in-middle win starty startx width str color)
  (let ((length (string-length str)))

    (attr-on! win color)
    (addstr win str
            #:y starty
            #:x (+ startx (/ (- width length) 2)))

    (attr-off! win color)
    (refresh)))


;; Initialize curses
(define stdscr (initscr))
(start-color!)
(cbreak!)
(noecho!)
(keypad! stdscr #t)

;;Initialize a few color pairs
(init-pair! 1 COLOR_RED COLOR_BLACK)

(define field (list
               (new-field 1 10 6 1 0 0)
               (new-field 1 10 8 1 0 0)))

;; Set field options
(set-field-back! (first field) A_UNDERLINE)
(field-opts-off! (first field) O_AUTOSKIP)

(set-field-back! (second field) A_UNDERLINE)
(field-opts-off! (second field) O_AUTOSKIP)

;; Create a new form
(define my-form (new-form field))

;; Calculate the area associated with the form
(define xy (scale-form my-form))
(define rows (car xy))
(define cols (cadr xy))

;; Create the window to be associated with the form
(define my-form-win (newwin (+ 4 rows)
                            (+ 4 cols)
                            4
                            4))
(keypad! my-form-win #t)

;; Set main window and subwindow
(set-form-win! my-form my-form-win)
(set-form-sub! my-form (derwin my-form-win rows cols 2 2))

;; Print a border around the main window and print a title
(box my-form-win 0 0)
(print-in-middle my-form-win 1 0 (+ cols 4) "My Form" (color-pair 1))

(post-form my-form)
(refresh my-form-win)

(addstr stdscr "Use UP, DOWN arrow keys to switch between fields"
        #:y (- (lines) 2) #:x 0)
(refresh stdscr)

;; Loop through to get user requests
(let loop ((ch (getch my-form-win)))
  (if (not (eqv? ch (key-f 1)))
      (cond
       ((eqv? ch KEY_DOWN)
        (begin
          ;; Go to the end of the next field
          (form-driver my-form REQ_NEXT_FIELD)
          (form-driver my-form REQ_END_LINE)
          (loop (getch my-form-win))))
       ((eqv? ch KEY_UP)
        (begin
          ;; Go to the end of the previous field
          (form-driver my-form REQ_PREV_FIELD)
          (form-driver my-form REQ_END_LINE)
          (loop (getch my-form-win))))
       (else
        (begin
          ;; Print any normal character
          (form-driver my-form ch)
          (loop (getch my-form-win)))))))

;; Unpost the form
(unpost-form my-form)

(endwin)
@end example

@node  Field Validation, The Form Driver, Form Windows, Forms Library
@subsection Field Validation

By default, a field will accept any data input by the user.  It is
possible to attach validation to the field.  Then any attempt by the
user to leave the field while it contains data that doesn't match the
validation type will fail.. Some validation types also have a
character-validity check for each type a character is entered in the
field.

Validation can be attached by using the @code{set-field-type!}
procedure and queried with the @code{field-type} procedure.

The form driver validates the data in a field only when data is entered
by the end-user.  Validation does not occur when the application
program changes the field value with @code{set-field-buffer!}.

The validation types are as follows.

@table @code

@item TYPE_ALPHA

This field type accepts alphabetic data; no blanks, no digits, no
special characters.  It takes a width argument that sets a minimum
width of the data.  The user has to enter at least that number of
characters be fore he can leave the field.  Typically you'll want to
set this to the field width.  If it's greater than the field width,
the validation check will always fail.  A minimum width of zero makes
field completion optional.

@example
(set-field-type! field TYPE_ALPHA width)
@end example

@item TYPE_ALNUM

This field type accepts alphabetic data and digits.  No blanks, no
special characters.  It also has a width argument.

@example
(set-field-type! field TYPE_ALPHA width)
@end example

@item TYPE_ENUM

This type allows you to restrict a field's values to be among a
specified set of string values (for example, the two-letter postal
codes for US states).  It takes as input a list of strings.  It can be
set up as either case sensitive or case insensitive.  When the user
exits, the validation procedure tries to complete the data in the
buffer to a valid entry.  If a complete choice string has been
entered, it is, of course, valid.  But it is also possible to enter a
prefix of a valid string and have it completed for you.

By default, if you enter such a prefix and it matches more than on
value in the string list, the prefix will be completed to the first
matching value.  If the check-unique option is chosen, the prefix
match must be unique to be valid.

@example
(set-field-type! field TYPE_ENUM valuelist checkcase checkunique)
@end example

@item TYPE_INTEGER

Valid characters consist of an optional leading minus and digits.  A
range check is performed on exit.  If the range maximum is less than
or equal to the minimum, the range is ignored.

@example
(set-field-type! field TYPE_INTEGER zero-padding min max)
@end example

If the value passes its range check, it is padded with as many leading
zero digits as necessary to meet the padding requirement.

@item TYPE_NUMERIC

This accepts a decimal number.

@example
(set-field-type! field TYPE_NUMERIC digits-of-precision min max)
@end example

Valid characters consist of a leading minus and digits, possibly
including a decimate point.  The range check is performed on exit.

If the value passes its range check, it is padded with as many
trailing zero digits as necessary to meet the padding argument.

@item TYPE_REGEXP

This field type accepts a regular expression, and thus can be used to
perform other types of range checks.

@end table

@node  The Form Driver,  , Field Validation, Forms Library
@subsection The Form Driver: The Work Horse of the System

The @code{form-driver} procedure plays a very important role in the
forms system.  All types of requests to forms should be funneled
through @code{form-driver}.

As you have seen some of the examples above, you have to be in a loop
looking for user input and then decide whether it is a field data or a
form request.  The form requests are then passes to @code{form-driver}
to do the work.

The requests roughly can be divided into the following categories.
Different request and their usage is explained below.

@subsubsection Page Navigation Requests

These requests cause page-level moves through the form, triggering
display of a new form screen.  A form can be made of multiple pages.
If you have a big form with lots of fields and logical sections, then
you can divide the form into pages.  The function @code{set-new-page}
sets a new page at the field specified.

Also, the following requests, when passed to the form driver, all you
to move to different pages.
@itemize @bullet
@item REQ_NEXT_PAGE
Move to the next form page.
@item REQ_PREV_PAGE
Move to the previous form page.
@item REQ_FIRST_PAGE
Move to the first form page.
@item REQ_LAST_PAGE
Move to the last form page.
@end itemize

These are cyclic.  The moving to the next page after the last page put
you at the top.

@subsubsection Inter-Field Navigation Requests
@itemize
@item REQ_NEXT_FIELD
Move to the next field
@item REQ_PREV_FIELD
Move to the previous field
@item REQ_FIRST_FIELD
Move to the first field.
@item REQ_LAST_FIELD
Move to the last field.
@item REQ_SNEXT_FIELD
Move to the sorted next field.
@item REQ_SPREV_FIELD
Move to the sorted previous field.
@item REQ_SFIRST_FIELD
Move to sorted first field.
@item REQ_SLAST_FIELD
Move to sorted last field.
@item REQ_LEFT_FIELD
Move left to field.
@item REQ_RIGHT_FIELD
Move right to field.
@item REQ_UP_FIELD
Move up one field.
@item REQ_DOWN_FIELD
Move down one field.
@end itemize

These requests treat fields as cyclic, moving off the end of the page
will return you to the top.



@node Curses Reference, Index, Curses Tutorial, Top
@chapter Curses Reference

The guile-ncurses package provides the following modules:
@enumerate
@item
@code{(ncurses curses)}: Basic functionality and input/output.

@item
@code{(ncurses panel)}: A library for managing overlapping windows.

@item
@code{(ncurses menu)}: A library for menu creation.

@item
@code{(ncurses form)}: A library for creating text-based form screens.

@item
@code{(ncurses slk)}: The soft keys functions.
@end enumerate

@menu
* The naming of routines::
* The basic curses library::
* Function key labels library::
* The curses panel library::
* The curses menu library::
* The curses form library::
@end menu

@node The naming of routines, The basic curses library, Curses Reference, Curses Reference
@section The naming of routines

When you look at this library, it may seem that exclamation points and
question marks were sprinkled at random on the ends of curses
functions.  There is actually a thought process behind it: it isn't
just chaos.

@itemize @bullet
@item
A procedure that returns @code{#t} or @code{#f} and @emph{does not}
change the behavior of the system in any way ends in a question
mark, e.g. @code{has-ic?}.
@item
But, a procedure that returns @code{#t} or @code{#f} and @emph{does}
change the behavior of the system does not end in a question mark,
e.g. @code{beep}.
@item
A procedure that changes any property of curses but does not write to
a window or screen ends in an exclamation point, e.g. @code{bkgdset!}.
@item
Any procedure that writes to a window or screen does not in an
exclamation point, e.g. @code{addch}.
@item
Curses integer constants are capitalized and use underscores, for
example @code{A_BOLD}.
@item
Curses procedures are not capitalized, even if they were capitalized
macros in the C Ncurses library, for example @code{lines} and
@code{tabsize}.
@end itemize


@node The basic curses library, Function key labels library, The naming of routines, Curses Reference
@section The basic curses library: @code{(ncurses curses)}

These are the functions in the @code{(ncurses curses)} module.

The procedures in the curses library closely follow the functions in
the C-language API.  Most of the procedures in the library have
approximately the same name and arguments as the functions in the
C-language API.

@menu
* Overview::
* Features determined at compile time::
* Curses screen initialization and manipulation routines::
* Errors and Exceptions::
* Making rendered characters::
* Adding characters::
* Adding strings of characters and attributes::
* Character and window attribute control routines::
* Bell and screen flash routines::
* Window background manipulation routines::
* Borders and lines::
* Clearing windows and parts of window::
* Color manipulation routines::
* Deleting the character under the cursor::
* Deleting and inserting lines::
* Getting characters from the keyboard::
* Handling unmapped keys::
* Receiving strings from the keyboard::
* Cursor location and window coordinates::
* Getting a rendered character from the window::
* Getting a string of characters and attributes from a window::
* Input options::
* Inserting a character before the cursor::
* Inserting a string before the cursor::
* Getting a string of characters from the screen::
* Low-level routines::
* Mouse handling::
* Moving the cursor ::
* Output options::
* Overlay and manipulate overlapped windows::
* Create and display pads::
* Print data to a terminal-attached ports::
* Refresh windows and lines::
* Reading and writing a curses screen to a file::
* Scroll a window::
* Terminal attributes::
* Refresh routines::
* Miscellaneous utilities::
* Window creation::
@end menu

@node Overview, Features determined at compile time, The basic curses library, The basic curses library
@subsection Overview

The GNU Guile-Ncurses library routines give the user a
terminal-independent method of updating character screens with
reasonable optimization.

The package supports overall screen, window and pad manipulation;
output to windows and pads; reading terminal input; control over
terminal and curses input and output options; environment query
routines; color manipulation; use of soft label keys; terminfo
capabilities; and access to low-level terminal-manipulation routines.

@findex initscr
@findex newterm
@findex endwin

To initialize the routines, the routine @code{initscr} or
@code{newterm} must be called before any of the other routines that
deal with windows and screens are used.  The routine @code{endwin} must be
called before exiting.  To get character-at-a-time input without
echoing (most interactive, screen oriented programs want this), the
following sequence should be used:

@findex initscr
@findex cbreak!
@findex noecho!

@example
(cbreak!)
(noecho!)
@end example

Most programs would additionally use the sequence:

@findex nonl!
@findex intrflush!
@findex keypad!

@example
(nonl!)
(intrflush! #f)
(keypad! stdscr #t))
@end example

@findex tset

Before a curses program is run, the tab stops of the terminal should
be set and its initialization strings, if defined, must be output.
This can be done by executing the @code{tput} init command after the
shell environment variable @env{TERM} has been exported.  @code{tset}
is usually responsible for doing this. [See terminfo for further
details.]

@findex stdscr
@tindex #<window>

The Guile-Ncurses library permits manipulation of data structures, the
@code{#<window>} type, which can be thought of as two-dimensional
arrays of characters representing all or part of a CRT screen.  A
default window, conventionally called @code{stdscr}, which is the size
of the terminal screen, is supplied. The @code{#<window>} information
for stdscr is returned by calling the procedure @code{initscr}.  Other
windows may be created with @code{newwin}.

Note that @code{(ncurses curses)} does not easily handle overlapping
windows.  Overlapping windows usually require the use of the
@code{(ncurses panel)} library.  Without the panel library, you can
either position everything on screen by hand or divide the screen into
tiled windows. Chose one of the two strategies and stick with it.
Mixing the two will result in unpredictable, and undesired, effects.

@findex addch
@findex move
@findex stdscr
@tindex #<window>

Windows are referred to by variables declared as @code{#<window>}.
These data structures are manipulated with routines described here.
Among those, the most basic routines are @code{move} and @code{addch}.
@code{move} places the cursor at a location in a buffer, and
@code{addch} puts a character at that location.


@findex refresh
@findex stdscr

After using routines to manipulate a window, @code{refresh} is called,
telling curses to make the user's CRT screen look like array of
characters in a @code{#<window>} buffer. Other information about the
character may also be stored with each character.

Special windows called @dfn{pads} may also be manipulated.  These are
windows which are not constrained to the size of the screen and whose
contents need not be completely displayed.

In addition to drawing characters on the screen, video attributes and
colors may be supported, causing the characters to show up in such
modes as underlined, in reverse video, or in color on terminals that
support such display enhancements.  Line drawing characters may be
specified to be output. On input, curses is also able to translate
arrow and function keys that transmit escape sequences into single
values.  The video attributes, line drawing characters, and input
values use names, such as @code{A_REVERSE}, @code{(acs-hline)},
and @code{KEY_LEFT}.

If the environment variables @env{LINES} and @env{COLUMNS} are set, or
if the program is executing in a window environment, line and column
information in the environment will override information read by
terminfo.

If the environment variable @env{TERMINFO} is defined, any program
using curses checks for a local terminal definition before checking in
the standard places. For example, if @env{TERM} is set to
@file{xterm}, then the compiled terminal definition is found in
@file{/usr/share/terminfo/x/xterm}

(The ``x'' is copied from the first letter of ``xterm'' to
avoid creation of huge directories.)  However, if @env{TERMINFO} is set to
@env{$HOME/myterms}, curses first checks @file{$HOME/myterms/x/xterm},
and if that fails, it then checks the standard location.

This is useful for developing experimental definitions or when write
permission in @file{/usr/share/terminfo} is not available.

The getter procedures @code{(lines)} and @code{(cols)} are defined in
@code{(ncurses curses)} and will be return the size of the screen at the
time @code{initscr} was called.

@c The guile-ncurses routines also define the @code{#<window>} getter
@c procedure @code{(curscr)} which is used for certain low-level
@c operations like clearing and redrawing a screen containing garbage.
@c The @code{(curscr)} can be used in only a few routines.


@subsubsection The Coordinate System
@cindex Coordinates

The @code{move} routine and routines that take @code{#:y} and
@code{#:x} arguments use a screen based coordinate system.  The
coordinate @code{y} always refers to the row (of the window), and
@code{x} always refers to the column.  The upper left-hand corner is
always (0,0).  @code{y} increases as one moves down the window, and
@code{x} increases as one moves left.

@menu
@end menu

@node Features determined at compile time, Curses screen initialization and manipulation routines, Overview, The basic curses library
@subsection Features determined at compile time

When the Guile-Ncurses library was compiled, tests were run
to see which features could be enabled.  There are two
variables that describe the capabilities of this build
of Guile-Ncurses.

@defvr Constant %wide-ncurses
This is set to @code{#t} if Guile-Ncurses is using the features
of the wide ncurses library @code{libncursesw}.  Otherwise, it
is @code{#f}.
@end defvr

@defvr Constant %ucs4-chars
This is set to @code{#t} if Guile-Ncurses expects that characters are
stored as UCS4 codepoints, such as in Guile 2.0.x.  It is @code{#f} if
Guile-Ncurses expects that characters are 8-bit only and stored
according to the current 8-bit locale.
@end defvr

@node Curses screen initialization and manipulation routines, Errors and Exceptions, Features determined at compile time, The basic curses library
@subsection Curses screen initialization and manipulation routines

@cindex Initialization
@cindex Screens, creation
@cindex Curses, initialization
@cindex Curses, ending
@cindex Curses, termination

@findex initscr
@findex slk-init
@findex %filter
@findex ripoffline
@findex use-env
@findex newterm

@code{initscr} is normally the first curses routine to call when
initializing a program.  A few special routines sometimes need to be
called before it; these are @code{slk-init}, @code{%filter},
@code{ripoffline}, @code{use-env}.  For multiple-terminal
applications, @code{newterm} may be called before @code{initscr}.

@findex initscr
@vindex stdscr

@deffn Procedure initscr
@cindex Curses, Initialization
@cindex Initialization
@findex refresh
@vindex stdscr

The @code{initscr} code determines the terminal type and initializes
all curses data structures.  @code{initscr} also causes the first call
to @code{refresh} to clear the screen.

The @code{#<window>} returned by @code{initscr} should be held in a
variable that exists for the lifetime of a curses program.  If it is
garbage collected, the window will become unusable.

If errors occur, @code{initscr} throws and error and exits; otherwise,
a @code{#<window>} referencing @code{stdscr} is returned.
@end deffn

@deffn Procedure cols
@deffnx Procedure lines

These procedures, if called after @code{initscr} has been called,
will return the size of the screen at the time initscr was called.
@end deffn

@tindex #<screen>
@vindex $TERM
@tindex #<file>
@findex fopen

@deffn Procedure newterm type outport inport
@findex newterm
The procedure @code{newterm} initializes curses for a given terminal
type @var{type} on specific curses port @var{inport} and
@var{outport}.  The @code{newterm} function relies on some relatively
obscure GNU C library functions and thus may not be available on
non-GNU systems.

The routine @code{newterm} should be called once for each terminal.
It returns a variable of type @code{#<screen>} which should be saved
as a reference to that terminal.  @var{type} is the type of the
terminal to be used in place of @env{$TERM}.  @var{outport} is a port
that will receive the output to the terminal.  It can be a port of any
type (file, string, etc.). @var{inport} is a port that will hold the
input to the terminal.  It must be a file port, and cannot be a string
port.

@code{newterm} will internally use a duplicate port to the file
pointed to by @var{inport}.  @var{inport} won't be used except to get a
file descriptor for the underlying file.

Immediately following the call to newterm, one should create a window
for the terminal by using the @code{stdscr} procedure.  So the standard way
to initialize it would be something like.
@example
(newterm "vt220" outport inport)
(define stdscr (stdscr))
@end example

This routine will throw an error if the terminal could not be created.
@end deffn

@findex newterm
@findex initscr
@findex endwin

A program that outputs to more than one terminal should use the
@code{newterm} routine for each terminal instead of @code{initscr}.  A
program that needs to inspect capabilities, so it can continue to run
in a line-oriented mode if the terminal cannot support a
screen-oriented program, would also use @code{newterm}.  The program
must also call @code{endwin} for each terminal being used before
exiting from curses.  If @code{newterm} is called more than once for
the same terminal, the first terminal referred to must be the last one
for which @code{endwin} is called.

@findex doupdate
@findex refresh

@deffn Procedure endwin
@cindex Curses mode, exiting
@cindex Exiting curses mode

A program should always call @code{endwin} before exiting or escaping
from curses mode temporarily.  This routine restores TTY modes, moves
the cursor to the lower left-hand corner of the screen and resets the
terminal into the proper non-visual mode.  Calling @code{refresh} or
@code{doupdate} after a temporary escape causes the program to resume
visual mode.

Its return value is @code{#t} if the terminal can be restored to its
behavior (as in @code{reset-shell-mode}), or @code{#f} otherwise.  If
the terminal was created by @code{newterm}, then this will usually
return @code{#f} since input file had no previous mode.

@end deffn

@deffn Procedure isendwin?
The @code{isendwin?} routine returns @code{#t} if @code{endwin} has
been called without any subsequent calls to @code{refresh}, and
@code{#f} otherwise.
@end deffn

@tindex #<screen>

@deffn Procedure set-term new
@cindex Terminals, switching
@cindex Screens, switching
@cindex Switching terminals

The @code{set-term} routine is used to switch between different
terminals.  If the program has created multiple terminal using the
@code{newterm} procedure, then @code{set-term} can be called to set
one of those terminal to be the current terminal on which all the
curses procedures will operate.  The screen reference @var{new}
becomes the new current terminal.  This is the only routine which
manipulates @code{#<screen>} types; all other routines affect only the
current terminal.

The return value is unspecified.
@end deffn

@findex delscreen
@findex endwin

@deffn Procedure delscreen screen
@cindex Screens, freeing

The delscreen routine frees storage associated with the @var{screen}
data structure.  The @code{endwin} routine does not do this, so
@code{delscreen} should be called after @code{endwin} if a particular
@var{screen} is no longer needed.  Trying to use a screen after it has
been freed will likely result in ``bad state'' errors.

@c The routine is called automatically when a screen is garbage
@c collected.

The return value is unspecified.

@end deffn

@node Errors and Exceptions, Making rendered characters, Curses screen initialization and manipulation routines, The basic curses library
@subsection Errors and Exceptions

The curses library uses SRFI-34's raise and SRFI-35 conditions to signal
errors.

All errors in the curses library are of type @code{&curses-error}.

@deffn Procedure curses-error? err
Returns true if @var{err} is a @code{&curses-error}
@end deffn

The wrong type error has two fields: @code{arg} and @code{expected-type}.

@deffn Procedure curses-wrong-type-arg-error? err
@deffnx Procedure curses-wrong-type-arg-error:arg err
@deffnx Procedure curses-wrong-type-arg-error:expected-type err
The predicate and accessors for the wrong type error.
@end deffn

@node Making rendered characters, Adding characters, Errors and Exceptions, The basic curses library
@subsection Making rendered characters

Many curses functions take rendered, complex characters: characters
with associated color and attribute information.

For those who are familiar with the C API for ncurses, you know that
a rendered character is either a @code{chtype}, which is a 32-bit
integer containing an 8-bit @code{char} and 24-bits of color and
rendering information, or is a @code{cchar_t}, which is one or more
@code{wchar_t} characters plus associated color and rendering
information.  Guile-Ncurses abstracts away the difference between
these two types and presents a consistent API for both.  The
Guile-Ncurses complex rendered character will get converted
automatically to @code{chtype} or @code{cchar_t} when necessary.

There is a family of functions to convert unrendered, simple
characters or strings to rendered complex characters and strings.

@deffn Procedure blink x
@deffnx Procedure bold x
@deffnx Procedure dim x
@deffnx Procedure horizontal x
@deffnx Procedure invis x
@deffnx Procedure left x
@deffnx Procedure low x
@deffnx Procedure normal x
@deffnx Procedure protect x
@deffnx Procedure inverse x
@deffnx Procedure right x
@deffnx Procedure standout x
@deffnx Procedure top x
@deffnx Procedure underline x
@deffnx Procedure vertical x

These procedures take @var{x}, which can be either a simple character,
a complex character, a simple string, or a complex string, and returns
a rendered character or string with the attribute blink, bold, dim,
horizontal, invisible, left, low, normal, protect, inverse, right,
top, underline, or vertical, respectively.  If the input @var{x} was a
rendered character or a rendered string, the old attributes are
replaced.  If @var{x} was a rendered character or string with an
associated color pair, the returned character or string will have the
same associated color pair.

Note that whether these attributes can actually be visualized depends
on the capabilities of the terminal itself.  Most terminals can handle
bold, dim, inverse, and sometimes blink, underline and invisible.  The
rest should probably not be used.

@end deffn

@deffn Procedure blink-on x
@deffnx Procedure bold-on x
@deffnx Procedure dim-on x
@deffnx Procedure horizontal-on x
@deffnx Procedure invis-on x
@deffnx Procedure left-on x
@deffnx Procedure low-on x
@deffnx Procedure normal-on x
@deffnx Procedure protect-on x
@deffnx Procedure inverse-on x
@deffnx Procedure right-on x
@deffnx Procedure standout-on x
@deffnx Procedure top-on x
@deffnx Procedure underline-on x
@deffnx Procedure vertical-on x

These procedures take @var{x}, which can be either a simple character,
a complex character, a simple string, or a complex string.  If @var{x}
is a simple character or simple string, it sets its rendering to
blink, bold, dim, horizontal, invisible, left, low, normal, protect,
inverse, right, top, underline, or vertical, respectively.  If the
input @var{x} was a rendered character or a rendered string, these
attributes are added to the rendered character.

Most terminals can't actually visualize multiple attributes on a
single character: some terminals can handle the combination of blink
and bold, bold and underline, or inverse and bold.

@end deffn

@deffn Procedure blink-off x
@deffnx Procedure bold-off x
@deffnx Procedure dim-off x
@deffnx Procedure horizontal-off x
@deffnx Procedure invis-off x
@deffnx Procedure left-off x
@deffnx Procedure low-off x
@deffnx Procedure normal-off x
@deffnx Procedure protect-off x
@deffnx Procedure inverse-off x
@deffnx Procedure right-off x
@deffnx Procedure standout-off x
@deffnx Procedure top-off x
@deffnx Procedure underline-off
@deffnx Procedure vertical-off x

These procedures take @var{x}, which can be either a simple character,
a complex character, a simple string, or a complex string.  If @var{x}
is a simple character or simple string, it sets its rendering to
normal.  If the input @var{x} was a rendered character or a rendered
string and had the given attribute, these attributes is removed from
the resulting rendered character.

@end deffn

@deffn Procedure color n x

These procedure takes @var{x}, which can be either a simple character,
a complex character, a simple string, or a complex string.  It returns
a rendered character or string with an associated color pair @var{n}.

This procedure should only be used if @code{start-color} has been
called.

@end deffn

There are a set of primitives to operate directly on complex characters.

@deffn Procedure xchar? c

Returns @code{#t} if @var{c} is a complex character.

@end deffn

@deffn Procedure xchar-attr c
@deffnx Procedure xchar-color c
@deffnx Procedure xchar-chars c
@cindex Complex characters, querying

These three procedures return the attributes, color pair number, and
list of constiuent characters of a complex character, respectively.

@end deffn

@deffn Procedure set-xchar-attr! c attr
@deffnx Procedure set-xchar-color! c color-pair-number
@deffnx Procedure set-xchar-chars! c list-of-chars
@cindex Complex characters, modifying

These procedures directly set the attributes, color-pair number, and
the list of characters of a complex character, respectively.

@end deffn

Complex characters can have a base character and a set of accent
characters that overwrite the base character.  That is why
@code{set-xchar-chars!} takes a list of characters, instead of a
single character.  But, for these complex characters to be rendered
correctly on the terminal, you need both a terminal that can do
overstrike characters and you need to have compiled with the wide
Ncurses library.  If either of these conditions are not true, only the
first character in the list of characters will appear on the screen.

There are also a couple of low-level functions to do conversion
between C characters and Guile characters.

@deffn Procedure %scheme-char-from-c-char c

Given an 8-bit integer @var{c} that represents a C character in the
current locale, this returns the associated scheme character.

@end deffn

@deffn Procedure %scheme-char-to-c-char c

This returns an 8-bit integer that is the C representation of
character @code{c} in the current locale.  If the character cannot be
represented in the current locale, it will return the integer 63,
which is the ASCII code for the question mark.

@end deffn

@deffn Procedure %scheme-char-from-c-wchar c

Given an integer @var{c} that represents a wchar_t representation of a
C wide character, this returns the associated scheme character.

@end deffn

@deffn Procedure %scheme-char-to-c-wchar c

This returns an integer that is the C @code{wchar_t} representation of
character @code{c}.  If the character cannot be represented in the
current locale, it will return the integer #xFFFD, which is the
Unicode codepoint for the replacement character.

@end deffn

@node Adding characters, Adding strings of characters and attributes, Making rendered characters, The basic curses library
@subsection Outputting characters
@cindex Characters, output
@cindex Outputting characters

There are two primary functions that add a rendered character
to a curses window, and then advance the cursor.

@deffn Procedure addch win ch #:key y x
@findex scrollok!

The @code{addch} routine puts the rendered character @var{ch} into the
given window at its current window position, which is then advanced.
If the advance is at the right margin, the cursor automatically wraps
to the beginning of the next line.  At the bottom of the current
scrolling region, if @code{scrollok!} is enabled, the scrolling region
is scrolled up one line.

@findex set-tabsize!
@findex clrtoeol

If @var{ch} is a tab, newline, or backspace, the cursor is moved
appropriately within the window.  Backspace moves the cursor one
character left; at the left edge of a window it does nothing. Newline
does a @code{clrtoeol}, then moves the cursor to the window left
margin on the next line, scrolling the window if on the last
line. Tabs are considered to be at every eighth column.  The tab
interval may be altered with the @code{set-tabsize!} procedure.

@findex inch

If @var{ch} is any control character other than @key{TAB}, @key{CR},
or @key{BS}, it is drawn in @code{^X} notation.  Calling @code{inch}
after adding a control character does not return the character itself,
but instead returns the @code{^}-representation of the control
character.

Since @var{ch} is a rendered character, the rendition will be applied
to the character when it is put on the screen.

This function returns @code{#t} on success and @code{#f} otherwise.  A
@code{#f} usually indicates an attempt to add a character that won't
fit on the screen or that would cause a wrap or scroll in a
window that doesn't wrap or scroll.

@end deffn

@deffn Procedure echochar win ch #:key y x

@findex addch
@findex refresh

The @code{echochar} routine is equivalent to a call to @code{addch}
followed by a call to @code{refresh}.  The knowledge that only a
single character is being output allows for efficiency.

This function returns @code{#t} on success and @code{#f} otherwise.  A
@code{#f} usually indicates an attempt to add a character that won't
fit on the screen or that would cause a wrap or scroll in a window
that doesn't wrap or scroll.
@end deffn

@deffn Procedure tabsize
Returns the current tabsize for this screen.  The default is eight.
@end deffn

@deffn Procedure set-tabsize! tab
Sets the tabsize for this screen to @var{tab} characters.

Its return value is unspecified.
@end deffn


@subsubsection  Line Graphics
@cindex Line graphics

The line-graphics procedures may be used to add line drawing
characters to the screen with routines of the @code{addch} family.
Not all terminals have line-graphics characters.  There is a default
character listed below is used if the @code{acsc} capability doesn't
define a terminal-specific replacement for it.  The names are taken
from VT100 nomenclature. Each of these procedures takes no arguments
and returns a rendered character with the 'normal' attribute and with
the default color pair.  The following prints a less-than-or-equal-to
sign to the window @code{win}, for example.

@example
(addch win (normal (acs-lequal)))
@end example

The set of line-graphics characters is given in @ref{tab:ACS}.

@float Table,tab:ACS
@multitable {acs-xxxxxxxxx} {default} {xxxxxxxxxxxxxxxxxxxxxxxxx}
@headitem name @tab default @tab description

@item @code{acs-block}
@tab #
@tab solid square block
@item @code{acs-board}
@tab #
@tab board of squares
@item @code{acs-btee}
@tab +
@tab bottom tee
@item @code{acs-bullet}
@tab o
@tab bullet
@item @code{acs-ckboard}
@tab :
@tab checker board (stipple)
@item @code{acs-darrow}
@tab v
@tab arrow pointing down
@item @code{acs-degree}
@tab '
@tab degree symbol
@item @code{acs-diamond}
@tab +
@tab diamond
@item @code{acs-gequal}
@tab >
@tab greater-than-or-equal-to
@item @code{acs-hline}
@tab -
@tab horizontal line
@item @code{acs-lantern}
@tab #
@tab lantern symbol
@item @code{acs-larrow}
@tab <
@tab arrow pointing left
@item @code{acs-lequal}
@tab <
@tab less-than-or-equal-to
@item @code{acs-llcorner}
@tab +
@tab lower left-hand corner
@item @code{acs-lrcorner}
@tab +
@tab lower right-hand corner
@item @code{acs-ltee}
@tab +
@tab left tee
@item @code{acs-nequal}
@tab !
@tab not-equal
@item @code{acs-pi}
@tab *
@tab greek pi
@item @code{acs-plminus}
@tab #
@tab plus/minus
@item @code{acs-plus}
@tab +
@tab plus
@item @code{acs-rarrow}
@tab >
@tab arrow pointing right
@item @code{acs-rtee}
@tab +
@tab right tee
@item @code{acs-s1}
@tab -
@tab scan line 1
@item @code{acs-s3}
@tab -
@tab scan line 3
@item @code{acs-s7}
@tab -
@tab scan line 7
@item @code{acs-s9}
@tab _
@tab scan line 9
@item @code{acs-sterling}
@tab f
@tab pound-sterling symbol
@item @code{acs-ttee}
@tab +
@tab top tee
@item @code{acs-uarrow}
@tab ^
@tab arrow pointing up
@item @code{acs-ulcorner}
@tab +
@tab upper left-hand corner
@item @code{acs-urcorner}
@tab +
@tab upper right-hand corner
@item @code{acs-vline}
@tab |
@tab vertical line
@end multitable
@caption{the line-graphics procedures}
@end float

@node Adding strings of characters and attributes, Character and window attribute control routines, Adding characters, The basic curses library
@subsection Outputting strings

@deffn Procedure addstr win #:key y x n

This routine writes the characters of the unrendered simple string
@var{str} on the given window.  When called with @var{n} it writes at
most n characters.  If @var{n} is -1, then the entire string will be
added, up to the maximum number of characters that will fit on the
line, or until a terminating null is reached.

It returns @code{#f} upon failure and @code{#t} on success.  Failure
usually indicates at attempt to write beyond the borders of the window
or to write in a place that would cause scroll or wrap on a window
that doesn't support it.

@end deffn

@deffn Procedure addchstr win chstr #:key y x n

These routines copy the rendered, complex string @var{chstr} into the
window image structure at and after the current cursor position.  If
@var{n} is defined, copy at most @var{n} elements, but no more than
will fit on the line.  If @var{n} equals -1 or if it is undefined,
then the whole string is copied, to the maximum number of characters
that will fit on the line.

@findex addstr

The window cursor is not advanced, and these routines work faster than
@code{addstr}.  On the other hand, they do not perform any kind of
checking (such as for the newline, backspace, or carriage return
characters), they do not advance the current cursor position, they do
not expand other control characters to ^-escapes, and they truncate
the string if it crosses the right margin, rather than wrapping it
around to the newline.

It returns @code{#f} upon failure and @code{#t} on success.

@end deffn

@node Character and window attribute control routines, Bell and screen flash routines, Adding strings of characters and attributes, The basic curses library
@subsection Character and window attribute control routines

@findex addch
@findex addstr

These routines manipulate the current attributes of the named window.
The current attributes of a window apply to all characters that are
written into the window with @code{addch} and @code{addstr}.
Attributes are a property of the character, and move with the
character through any scrolling and insert/delete line/character
operations.  To the extent possible, they are displayed as appropriate
modifications to the graphic rendition of characters put on the
screen.

@deffn Procedure attr-set! win attrs #:optional color
@deffnx Procedure attr-on! win attrs
@deffnx Procedure attr-off! win attrs
@deffnx Procedure standend! win
@deffnx Procedure standout! win
@cindex Attributes

The routine @code{attr-set!} sets the current rendition (attributes
and color pair) of the given window to @var{attrs}.  Optionally, you
may split the color-pair information as a third parameter.

@var{attrs} is one of the attribute constants: there is an attribute
constant for each of the attributes mentioned in @ref{Making rendered
characters}: A_BLINK, A_BOLD, A_DIM, A_INVIS, A_NORMAL, A_PROTECT,
A_REVERSE, A_STANDOUT, A_UNDERLINE, A_HORIZONTAL, A_LEFT, A_LOW,
A_RIGHT, A_TOP, A_VERTICAL.

@comment A_ALTCHARSET,  A_ATTRIBUTES
@comment            A_CHARTEXT
@comment            A_COLOR

The following two calls are equivalent:
@example
(attr-set! win (logior A_BOLD (color-pair 1)))
@end example
or
@example
(attr-set! win A_BOLD 1)
@end example

The routine @code{attr-off!} turns off the named
attributes without turning any other attributes on or off.  The
routine @code{attr-on!} turns on the named attributes without affecting
any others.  The routine @code{standout!} is the same as @code{(attr-on!
A_STANDOUT)}.  The routine @code{standend!} is the same as
@code{(attr-set! A_NORMAL)} or @code{(attr-set! 0)}, that is, it turns off
all attributes.

The return value of these routines are undefined.  They can throw an
exception if curses is in a bad state.

@end deffn

The @code{attr-set!} and related routines do not affect the attributes
used when erasing portions of the window. For functions which modify
the attributes used for erasing and clearing @xref{Window background
manipulation routines}.

@deffn Procedure color-set! win color-pair-number

The routine @code{color-set!} sets the current color of the given
window to the foreground/background combination described by the
@var{color-pair-number}.

The return value is unspecified, but, it can throw an error if the
color pair number was too large.
@end deffn

@deffn Procedure attr-get

The routine @code{attr-get} returns the current attribute and color
pair for the given window.  They are returned as a list containing two
elements.  The first element is a bitmap containing all the
attributes.  The second element is the color pair alone.

@end deffn

@deffn Procedure chgat win n attr color #:key y x

@findex init-pair!

The routine @code{chgat} changes the attributes of a given number of
characters starting at the current cursor location of @code{stdscr} or
of @var{win} if it is given.  It does not update the cursor and does
not perform wrapping.  A character count of -1 or greater than the
remaining window width means to change attributes all the way to the
end of the current line.  If @var{y} and @var{x} are given, the
function does a cursor move before acting.  In these functions, the
@var{color} argument is a color-pair index as in the first argument of
@code{init-pair!}. @xref{Color manipulation routines}.

The return value is unspecified.

@end deffn

The attributes can be passed to the routines @code{attr-on!},
@code{attr-off!}, and @code{attr-set!}, or @code{logior}'d with the
characters passed to @code{addch}.  For the color part of the
rendition, use @code{color-pair}.  @xref{tab:a}.

@deffn Procedure color-pair n
@cindex Color pairs

Returns a bit mask to apply the color pair @var{n} to a rendition.
@code{color-pair} values can only be @code{logior}'ed with attributes
if the pair number is less than 256.  The alternate functions such as
@code{color-set!} can pass a color pair value directly.
@end deffn

For example, the following two calls are equivalent ways of
setting the default attribute of the screen to be bold and
have color-pair #1.
@example
(attr-set! win (logior A_BOLD (color-pair 1)))
@end example
or
@example
(attr-set! win A_BOLD 1)
@end example

@deffn Procedure pair-number attrs
@cindex Color pairs

This function is the inverse operation of @code{color-pair}.  It is
rarely useful.
@example
(color-pair 1) ==> 256
(pair-number 256) ==> 1
@end example

@end deffn

@float Table,tab:a
@multitable {A_ALTCHARSET} {Best highlighting mode of the terminal.}
@headitem Name @tab Description

@item  A_NORMAL
@tab Normal display (no highlight)

@item  A_STANDOUT
@tab Best highlighting mode of the terminal.

@item  A_UNDERLINE
@tab Underlining

@item  A_REVERSE
@tab Reverse video

@item  A_BLINK
@tab Blinking

@item  A_DIM
@tab Half bright

@item  A_BOLD
@tab Extra bright or bold

@item  A_PROTECT
@tab Protected mode

@item  A_INVIS
@tab Invisible or blank mode

@item  A_ALTCHARSET
@tab Alternate character set

@item  A_CHARTEXT
@tab Bit-mask to extract a character

@end multitable
@caption{Attributes}
@end float

@node Bell and screen flash routines, Window background manipulation routines, Character and window attribute control routines, The basic curses library
@subsection Bell and screen flash routines

@deffn Procedure beep
@deffnx Procedure flash

@cindex Beeping
@cindex Flashing the screen

The @code{beep} and @code{flash} routines are used to alert the
terminal user.  The routine beep sounds an audible alarm on the
terminal, if possible; otherwise it flashes the screen (visible bell).
The routine flash flashes the screen, and if that is not possible,
sounds the alert.  If neither alert is possible, nothing happens.
Nearly all terminals have an audible alert (bell or beep), but only
some can flash the screen.

These routines return @code{#t} if they succeed in beeping or
flashing, @code{#f} otherwise.

@end deffn

@node Window background manipulation routines, Borders and lines, Bell and screen flash routines, The basic curses library
@subsection Window background manipulation routines
@cindex Windows, background
@cindex Background

@deffn Procedure bkgdset! win ch
@findex addch

The @code{bkgdset!} routine manipulates the background of the named
window.  The window background is set to the rendered complex
character @var{ch}. The attribute part of the @var{ch} is combined
(@code{logior}'d) with all non-blank characters that are written into
the window with @code{addch}.  Both the character and attribute parts
of the @var{ch} are combined with the blank characters.  The
background becomes a property of the character and moves with the
character through any scrolling and insert/delete line/character
operations.

To the extent possible on a particular terminal, the attribute part of
the background is displayed as the graphic rendition of the character
put on the screen.

The return value is undefined.

@end deffn

@deffn Procedure bkgd win ch
The @code{bkgd} function sets the background property
of the current or specified window and then applies this setting to
every character position in that window: The rendition of every
character on the screen is changed to the new background rendition.
Wherever the former background character appears, it is changed to the
new background character.

The return value is undefined.
@end deffn

@deffn Procedure getbkgd win
@cindex Windows, background
@cindex Background rendition

The @code{getbkgd} function returns the given window's current background
rendered character.

@end deffn

@node Borders and lines, Clearing windows and parts of window, Window background manipulation routines, The basic curses library
@subsection Borders and lines


@deffn Procedure border win ls rs ts bs tl tr bl br

The @code{border} routine draws a box around the edges of a
window. Other than @var{win}, each argument is a rendered character,
representing a side or a corner of the border.  The arguments are
@var{ls} - left side, @var{rs} - right side, @var{ts} - top side,
@var{bs} - bottom side, @var{tl} - top left-hand corner, @var{tr} -
top right-hand corner, @var{bl} - bottom left-hand corner, and
@var{br} - bottom right-hand corner.

If  any of these arguments is zero, then the corresponding default
values are used instead.  The default values are the line drawing
characters that create a box, and they would be @var{ls} =
@code{acs-vline}, @var{rs} = @code{acs-vline}, @var{ts} =
@code{acs-hline}, @var{bs} = @code{acs-hline}, @var{tl} =
@code{acs-ulcorner}, @var{tr} = @code{acs-urcorner}, @var{bl} =
@code{acs-llcorner}, @var{br} = @code{acs-lrcorner}.

The characters used should have the standard character width.
Double-width characters should not be used in borders.

It returns @code{#f} on failure and @code{#t} on success.
@end deffn

@deffn Procedure box win verch horch
@code{box} is a shorthand for the following call:
@example
(border win verch verch horch horch 0 0 0 0)
@end example
@end deffn


@deffn Procedure hline win ch n #:key y x

The @code{hline} procedure draws a horizontal (left to right) line
using @var{ch} starting at the current cursor position in the window.
The current cursor position is not changed.  The line is at most
@var{n} characters long, or as many as fit into the window.

The optional parameters @var{y} and @var{x} cause the cursor to be
moved to that position before drawing the line.

The return value is unspecified.
@end deffn


@deffn Procedure vline win ch n #:key y x

The @code{vline} procedure draws a vertical (top to bottom) line using
@code{ch} starting at the current cursor position in the window.  The
current cursor position is not changed.  The line is at most @code{n}
characters long, or as many as fit into the window.

If the key parameters @var{y} and @var{x} are set, it moves the cursor
before drawing the line.

The return value is unspecified.
@end deffn

@node Clearing windows and parts of window, Color manipulation routines, Borders and lines, The basic curses library
@subsection Clearing windows and parts of window

@findex bkgdset!

The following family of functions @dfn{clear} all or part of a window.
When clearing a window, the blanks created by erasure have the current
background rendition (as set by @code{bkgdset!}) merged into them.

@deffn Procedure erase win

The @code{erase} routine copies blanks to every
position in the window, clearing the screen.

It returns @code{#f} on failure and @code{#t} on success.

@end deffn

@deffn Procedure clear win

@findex erase
@findex clearok!
@findex refresh
@cindex Erasing the screen
@cindex Clearing the screen
@cindex Screens, clearing
@cindex Screens, erasing

The @code{clear} routine is like @code{erase}, but they also call
@code{clearok!}, so that the screen is cleared completely on the next
call to @code{refresh} for that window and repainted from scratch.

Its return value is unspecified.
@end deffn

@deffn Procedure clrtobot win

The @code{clrtobot} routine erase from the cursor to the end of
screen. That is, they erase all lines below the cursor in the window.
Also, the current line to the right of the cursor, inclusive, is
erased.

Its return value is unspecified.
@end deffn

@deffn Procedure clrtoeol win

The @code{clrtoeol} routine erase the current line to the right
of the cursor, inclusive, to the end of the current line.

It returns @code{#f} on failure and @code{#t} on success.  Failure
could occur if the cursor position is offscreen.
@end deffn

@node Color manipulation routines, Deleting the character under the cursor, Clearing windows and parts of window, The basic curses library
@subsection Color manipulation routines
@cindex Colors, manipulation
@findex initscr
@findex init-pair!
@findex color-pair

Curses supports color attributes on terminals with that capability.  To
use these routines @code{start-color!} must be called, usually right
after @code{initscr}.  Colors are always used in pairs (referred to as
color-pairs).  A color-pair consists of a foreground color (for
characters) and a background color (for the blank field on which the
characters are displayed).  A programmer initializes a color-pair with
the routine @code{init-pair!}.  After it has been initialized,
@code{color-pair} can be used as a new video attribute.

If a terminal is capable of redefining colors, the programmer can use
the routine @code{init-color!} to change the definition of a color.
The routines @code{has-colors?} and @code{can-change-color?} return
@code{#t} or @code{#f}, depending on whether the terminal has color
capabilities and whether the programmer can change the colors.  The
routine @code{color-content} allows a programmer to extract the
amounts of red, green, and blue components in an initialized color.
The routine @code{pair-content} allows a programmer to find out how a
given color-pair is currently defined.

@deffn Procedure start-color!
@cindex Colors, initialization
@findex initscr
@findex colors
@findex color-pairs

The @code{start-color!} routine requires no arguments.  It must be
called if the programmer wants to use colors, and before any other
color manipulation routine is called.  It is good practice to call
this routine right after @code{initscr}. @code{start-color!}
initializes eight basic colors (black, red, green, yellow, blue,
magenta, cyan, and white), and prepares the procedures @code{colors} and
@code{color-pairs} (respectively defining the maximum number of colors
and color-pairs the terminal can support).  It also restores the
colors on the terminal to the values they had when the terminal was
just turned on.

The return value is unspecified.
@end deffn

@deffn Procedure colors
Returns the maximum number of colors the terminal can support.
@end deffn

@deffn Procedure color-pairs
Returns the maximum number of color-pairs the terminal can support.
@end deffn


@defvr Constant COLOR_BLACK
@defvrx Constant COLOR_RED
@defvrx Constant COLOR_GREEN
@defvrx Constant COLOR_YELLOW
@defvrx Constant COLOR_BLUE
@defvrx Constant COLOR_MAGENTA
@defvrx Constant COLOR_CYAN
@defvrx Constant COLOR_WHITE

@findex init-color!
These variables contain the color number of the eight default colors.
@end defvr


@deffn Procedure init-color! color red green blue
@cindex Colors, defining

The @code{init-color!} routine changes the definition of a color.  It
takes four arguments: the number of the color to be changed followed
by three RGB values (for the amounts of @var{red}, @var{green}, and
@var{blue} components).  The value of the first argument must be
between 0 and the value returned by the @code{colors} procedure. Each
of the last three arguments must be a value between 0 and 1000.  When
@code{init-color!} is used, all occurrences of that color on the screen
immediately change to the new definition.

It returns @code{#f} on failure and @code{#t} on success.  Failure may
indicate that, for the current terminal, the colors cannot be modified.
@end deffn

@deffn Procedure init-pair! color-pair fore-color back-color

The @code{init-pair!} routine changes the definition of a color-pair.
It takes three arguments: the number of the color-pair to be changed,
the fore-ground color number, and the background color number.

@findex color-pairs

The value of the first argument must be between 1 and
@code{color-pairs - 1}.

@findex colors

The value of the second and third arguments must be between 0 and
@code{colors}.  Color pair 0 is assumed to be white on black, but is
actually whatever the terminal implements before color is initialized.

If the color-pair was previously initialized, the screen is refreshed
and all occurrences of that color-pair are changed to the new definition.

@findex assume-default-colors
@findex use-default-colors
@cindex Color, default

Color pair 0 is set via the @code{assume-default-colors} routine.
After @w{@code{use-default-colors}} has been called, the special color
number @code{-1} can be used as @var{fore-color} or
@var{back-color}. Color number @code{-1} is set to contain the default
foreground or background color for this screen, which is usually white
on black.

It returns @code{#f} on failure and @code{#t} on success.  Failure may
indicate an attempt to change a color pair beyond the allow range of
color pairs.
@end deffn


@deffn Procedure has-colors?
@cindex Color capability
@cindex Terminal capabilities, color

The @code{has-colors?} routine returns @code{#t} if the terminal can
manipulate colors; otherwise, it returns @code{#f}.  This routine
facilitates writing terminal-independent programs. For example, a
programmer can use it to decide whether to use color or some other
video attribute.

@end deffn

@deffn Procedure can-change-color?
@cindex Color capabilities
@cindex Terminal capabilities, color

The @code{can-change-color?} routine returns @code{#t} if the terminal
supports colors and can change their definitions; otherwise, it
returns @code{#f}.
@end deffn

@deffn Procedure color-content color
@findex colors
The @code{color-content} routine returns the intensity of the red,
green, and blue (RGB) components in a color.  Given @var{color} as its
argument, it returns a list of three integers indicating the red,
green, and blue components in the given color.  The value of the
@var{color} argument must be between 0 and the value returned by the
@code{colors} procedure.  The values returned are between 0 (no
component) and 1000 (maximum amount of component).

@end deffn

@deffn Procedure pair-content pair

The @code{pair-content} routine allows programmers to find out what
colors color-pair @var{pair} consists of.  The value of @var{pair}
must be between 1 and @code{color-pairs - 1}.  It returns a list of
two elements: the foreground color number and the background color
number. The values are between 0 and the value returned by
@code{colors}.

@end deffn

@deffn Procedure use-default-colors

@findex init-pair!

This procedure allow routines that use color numbers, like
@code{init-pair!} to use the special color number -1 to indicate the
default color.  When -1 is used in lieu of the foreground color, it
indicated the default foreground color.  When -1 is used as the
background color, it indicated the default background color.  Thus, it
has different meanings depending on the context.

It returns @code{#t} if successful or @code{#f} is the terminal lacks
the capability to set color pair 0.

@end deffn

@deffn Procedure assume-default-colors fg bg

@cindex Default colors
@cindex Colors, default
@findex init-pair!

This procedure allow the modification of special color pair 0, which
cannot be modified by @code{init-pair!}.  Color pair 0 is the default
foreground and background color for the window.

It returns @code{#t} if successful or @code{#f} is the terminal lacks
the capability to set color pair 0.

@end deffn

@node Deleting the character under the cursor, Deleting and inserting lines, Color manipulation routines, The basic curses library
@subsection Deleting the character under the cursor

@deffn Procedure delch win #:key y x

This routine deletes the character under the cursor; all characters to
the right of the cursor on the same line are moved to the left one
position and the last character on the line is filled with a blank.
The cursor position does not change (after moving to y, x, if
specified).  (This does not imply use of the hardware delete character
feature.)

It returns @code{#f} on failure and @code{#t} on success.
@end deffn

@node Deleting and inserting lines, Getting characters from the keyboard, Deleting the character under the cursor, The basic curses library
@subsection Deleting and inserting lines


@deffn Procedure deleteln win

The @code{deleteln} procedure deletes the line under the cursor in the
window; all lines below the current line are moved up one line.  The
bottom line of the window is cleared.  The cursor position does not
change.

It returns @code{#f} on failure and @code{#t} on success.
@end deffn

@deffn Procedure insdelln win n

The @code{insdelln} routine, for positive @var{n}, inserts @var{n}
lines into the specified window above the current line.  The @var{n}
bottom lines are lost.  For negative @var{n}, it deletes n lines
(starting with the one under the cursor), and move the remaining lines
up.  The bottom n lines are cleared.  The current cursor position
remains the same.

It returns @code{#f} on failure and @code{#t} on success.
@end deffn

@deffn Procedure insertln win

The @code{insertln} routine inserts a blank line above the current
line and the bottom line is lost.

It returns @code{#f} on failure and @code{#t} on success.
@end deffn


@node Getting characters from the keyboard, Handling unmapped keys, Deleting and inserting lines, The basic curses library
@subsection Getting characters from the keyboard

@deffn Procedure getch win #:key y x
@cindex Input
@findex cbreak!
@findex nocbreak!
@cindex Inputting characters

The @code{getch} routine reads a character from the terminal
associated with the given window.  In no-delay mode, if no input is
waiting, the value @code{#f} is returned.  In delay mode, the program
waits until the system passes text through to the program.  Depending
on the setting of cbreak, this is after one character (@code{cbreak}
mode), or after the first newline (@code{nocbreak!} mode).  In
@code{halfdelay!} mode, the program waits until a character is typed
or the specified timeout has been reached.

@findex noecho!
@findex delch
@findex beep

Unless @code{noecho!} has been set, then the character will also be
echoed into the designated window according to the following rules: If
the character is the current erase character, left arrow, or
backspace, the cursor is moved one space to the left and that screen
position is erased as if @code{delch} had been called.  If the
character value is any other @code{KEY_} define, the user is alerted with a
@code{beep} call.  Otherwise the character is simply output to the
screen.

@findex keypad!

If @code{keypad!} is @code{#t}, and a function key is pressed, the
integer keycode for that function key is returned instead of the raw
characters. There is a list of possible function keys.
@xref{tab:key}.

When a character that could be the beginning of a function key is
received (which, on modern terminals, means an escape character),
curses sets a timer.  If the remainder of the sequence does not come
in within the designated time, the character is passed through;
otherwise, the function key value is returned.  For this reason, many
terminals experience a delay between the time a user presses the
escape key and the escape is returned to the program.

@findex refresh

If the window is not a pad, and it has been moved or modified since
the last call to @code{refresh}, @code{refresh} will be called
before another character is read.

@end deffn

@deffn Procedure ungetch ch

@findex wgetch

The ungetch routine places @var{ch} back onto the input queue to be
returned by the next call to @code{getch}.  There is just one input
queue for all windows.

It returns @code{#f} if there is no more space in the buffer, or
@code{#t} otherwise.

@end deffn

@deffn Procedure key-f n
This procedure returns the keycode for function key @var{n}.
@end deffn

@findex getch
@findex keypad!

The following function keys, might be returned by @code{getch} if
@code{keypad!} has been enabled.

Note that almost all of these function keys do not exist on modern
keyboards.  The standard PC keyboard cannot be depended upon to have
more than @code{(key-f 1)} through @code{(key-f 12)}, @code{KEY_PPAGE}
(Page Up), @code{KEY_NPAGE} (Page Down), @code{KEY_HOME},
@code{KEY_END}, @code{KEY_IC} (Insert), @code{KEY_DC} (Delete),
@code{KEY_BACKSPACE}, @code{KEY_DC} (Delete), @code{KEY_UP},
@code{KEY_DOWN}, @code{KEY_LEFT}, and @code{KEY_RIGHT}.

Also, a common terminal is more likely to return @kbd{C-M} than
@code{KEY_ENTER} when the @key{RET} key is pressed.


@cindex Keycodes

@float Table,tab:key
@multitable {@code{KEY_BACKSPACE} xx} {Home down or bottom (lower left) xxxx}
@headitem name @tab description
@item @code{KEY_BREAK} @tab Break key
@item @code{KEY_DOWN} @tab Arrow down
@item @code{KEY_UP} @tab Arrow up
@item @code{KEY_LEFT} @tab Arrow left
@item @code{KEY_RIGHT} @tab Arrow right
@item @code{KEY_HOME} @tab Home key
@item @code{KEY_BACKSPACE} @tab Backspace
@item @code{KEY_F0} @tab Function key zero
@item @code{KEY_DL} @tab Delete line
@item @code{KEY_IL} @tab Insert line
@item @code{KEY_DC} @tab Delete character
@item @code{KEY_IC} @tab Insert char or enter insert mode
@item @code{KEY_EIC} @tab Exit insert char mode
@item @code{KEY_CLEAR} @tab Clear screen
@item @code{KEY_EOS} @tab Clear to end of screen
@item @code{KEY_EOL} @tab Clear to end of line
@item @code{KEY_SF} @tab Scroll 1 line forward
@item @code{KEY_SR} @tab Scroll 1 line backward (reverse)
@item @code{KEY_NPAGE} @tab Next page
@item @code{KEY_PPAGE} @tab Previous page
@item @code{KEY_STAB} @tab Set tab
@item @code{KEY_CTAB} @tab Clear tab
@item @code{KEY_CATAB} @tab Clear all tabs
@item @code{KEY_ENTER} @tab Enter or send
@item @code{KEY_SRESET} @tab Soft (partial) reset
@item @code{KEY_RESET} @tab Reset or hard reset
@item @code{KEY_PRINT} @tab Print or copy
@item @code{KEY_LL} @tab Home down or bottom (lower left)
@item @code{KEY_A1} @tab Upper left of keypad
@item @code{KEY_A3} @tab Upper right of keypad
@item @code{KEY_B2} @tab Center of keypad
@item @code{KEY_C1} @tab Lower left of keypad
@item @code{KEY_C3} @tab Lower right of keypad
@item @code{KEY_BTAB} @tab Back tab key
@item @code{KEY_BEG} @tab Beg(inning) key
@item @code{KEY_CANCEL} @tab Cancel key
@item @code{KEY_CLOSE} @tab Close key
@item @code{KEY_COMMAND} @tab Cmd (command) key
@item @code{KEY_COPY} @tab Copy key
@item @code{KEY_CREATE} @tab Create key
@item @code{KEY_END} @tab End key
@item @code{KEY_EXIT} @tab Exit key
@item @code{KEY_FIND} @tab Find key
@item @code{KEY_HELP} @tab Help key
@item @code{KEY_MARK} @tab Mark key
@item @code{KEY_MESSAGE} @tab Message key
@end multitable
@caption{the keypad constants, part 1}
@end float


@float Table,tab:key2
@multitable {@code{KEY_BACKSPACE} xx} {Home down or bottom (lower left) xxxx}
@headitem name @tab description
@item @code{KEY_MOUSE} @tab Mouse event read
@item @code{KEY_MOVE} @tab Move key
@item @code{KEY_NEXT} @tab Next object key
@item @code{KEY_OPEN} @tab Open key
@item @code{KEY_OPTIONS} @tab Options key
@item @code{KEY_PREVIOUS} @tab Previous object key
@item @code{KEY_REDO} @tab Redo key
@item @code{KEY_REFERENCE} @tab Ref(erence) key
@item @code{KEY_REFRESH} @tab Refresh key
@item @code{KEY_REPLACE} @tab Replace key
@item @code{KEY_RESIZE} @tab Screen resized
@item @code{KEY_RESTART} @tab Restart key
@item @code{KEY_RESUME} @tab Resume key
@item @code{KEY_SAVE} @tab Save key
@item @code{KEY_SBEG} @tab Shifted beginning key
@item @code{KEY_SCANCEL} @tab Shifted cancel key
@item @code{KEY_SCOMMAND} @tab Shifted command key
@item @code{KEY_SCOPY} @tab Shifted copy key
@item @code{KEY_SCREATE} @tab Shifted create key
@item @code{KEY_SDC} @tab Shifted delete char key
@item @code{KEY_SDL} @tab Shifted delete line key
@item @code{KEY_SELECT} @tab Select key
@item @code{KEY_SEND} @tab Shifted end key
@item @code{KEY_SEOL} @tab Shifted clear line key
@item @code{KEY_SEXIT} @tab Shifted exit key
@item @code{KEY_SFIND} @tab Shifted find key
@item @code{KEY_SHELP} @tab Shifted help key
@item @code{KEY_SHOME} @tab Shifted home key
@item @code{KEY_SIC} @tab Shifted input key
@item @code{KEY_SLEFT} @tab Shifted left arrow key
@item @code{KEY_SMESSAGE} @tab Shifted message key
@item @code{KEY_SMOVE} @tab Shifted move key
@item @code{KEY_SNEXT} @tab Shifted next key
@item @code{KEY_SOPTIONS} @tab Shifted options key
@item @code{KEY_SPREVIOUS} @tab Shifted prev key
@item @code{KEY_SPRINT} @tab Shifted print key
@item @code{KEY_SREDO} @tab Shifted redo key
@item @code{KEY_SREPLACE} @tab Shifted replace key
@item @code{KEY_SRIGHT} @tab Shifted right arrow
@item @code{KEY_SRESUME} @tab Shifted resume key
@item @code{KEY_SSAVE} @tab Shifted save key
@item @code{KEY_SSUSPEND} @tab Shifted suspend key
@item @code{KEY_SUNDO} @tab Shifted undo key
@item @code{KEY_SUSPEND} @tab Suspend key
@item @code{KEY_UNDO} @tab Undo key
@end multitable
@caption{the keypad constants, part 2}
@end float

@deffn Procedure has-key? ch
@cindex Terminal capabilities, keys
@cindex Keys
@findex resizeterm

The @code{has-key?} routine takes a key value @var{ch} from the above
list, and returns @code{#t} or @code{#f} according to whether the
current terminal type recognizes a key with that value.  Note that a
few values do not correspond to a real key, e.g., @code{KEY_RESIZE}
and @code{KEY_MOUSE}.  See @code{resizeterm} for more details about
@code{KEY_RESIZE}.  For a discussion of @code{KEY_MOUSE} see
@ref{Mouse handling}.

@end deffn

Use of the @key{ESC} key by a programmer for a single character function
is discouraged, as it will cause a delay of up to one second while the
keypad code looks for a following function-key sequence.

Note that some keys may be the same as commonly used control keys,
e.g., KEY_ENTER versus @kbd{C-M}, KEY_BACKSPACE versus @kbd{C-H}.
Some curses implementations may differ according to whether they treat
these control keys specially (and ignore the terminfo), or use the
terminfo definitions.  Ncurses uses the terminfo definition.  If it
says that KEY_ENTER is @kbd{C-M}, @code{getch} will return
@code{KEY_ENTER} when you press @kbd{C-M}.

When using @code{getch}, @code{wgetch}, @code{mvgetch}, or
@code{mvwgetch}, nocbreak mode (@code{nocbreak!}) and echo mode
(@code{echo!}) should not be used at the same time.  Depending on the
state of the TTY driver when each character is typed, the program may
produce undesirable results.

Historically, the set of keypad macros was largely defined by the
extremely function-key-rich keyboard of the AT&T 7300, aka 3B1, aka
Safari 4.  Modern personal computers usually have only a small subset
of these.  IBM PC-style consoles typically support little more than
@code{KEY_UP}, @code{KEY_DOWN}, @code{KEY_LEFT},
@code{KEY_RIGHT}, @code{KEY_HOME}, @code{KEY_END},
@code{KEY_NPAGE}, @code{KEY_PPAGE}, and function keys 1 through
12.  The ins key is usually mapped to @code{KEY_IC}

@node Handling unmapped keys, Receiving strings from the keyboard, Getting characters from the keyboard, The basic curses library
@subsection Handling unmapped keys

@cindex Keys, unmapped
@cindex Keys, custom

For most every modern-day terminal, you'll find that if you get the
@env{TERM} environment variable set correctly, then each of the
function keys on the keyboard will be interpreted as a key code.

But in rare circumstances, you may find that a function key on your
keyboard is not being mapped to a keycode.  As an example, on some
keyboards there is a special ``menu'' key in between @key{Ctrl} and
@key{Alt}.  On my keyboard, pressing ``menu'' returns ``@key{ESC}
@key{[} @key{2} @key{9} @key{~}'', which @code{getch} returns as a
that 5 separate characters, instead of a single keycode like
@code{KEY_MENU}.

When this happens, the problem is most often that you've set your
@env{TERM} incorrectly.  Next most likely is that your terminfo or
termcap database is out of date.  That is where you should first seek
your solution.

But, if that fails, and you need a quick-and-dirty workaround,
@code{define-key} can help.  It lets you map an escape sequence to a
key code.

Continuing my example, if I choose to map this menu key to a keycode,
I can choose the keycode of a key that that doesn't appear on my
keyboard, like @code{KEY_FIND}, and associate with that string, using
@code{define-key}.

@deffn Procedure define-key defn keycode
@cindex Keycodes, customizing
This procedure defines a new, custom @var{keycode}.  When the string
in @code{defn} is input, routines like @code{getch} will return the
keycode instead, if the keypad is on.  If @var{defn} is an empty
string, the keycode will be cleared.

If @var{keycode} is an existing keycode, its @var{defn} replaces its
previous definition.

The return value is @code{#t} on success.
@end deffn

For the example, I can use the command
@lisp
 (define-key (string #\esc #\[ #\2 #\9 #\~) KEY_FIND)
@end lisp
From that point on, when the Menu key is pressed, @code{getch} will
return the integer @code{KEY_FIND}.

@deffn Procedure key-defined defn
@cindex Keycodes, lookup

If the string @var{defn} is a character sequence that is bound to a keycode,
that keycode is returned.  Otherwise @code{#f} is returned.

@end deffn

@node Receiving strings from the keyboard, Cursor location and window coordinates, Handling unmapped keys, The basic curses library
@subsection Receiving strings from the keyboard

@deffn Procedure getnstr win n #:key y x

@findex getch

The procedure @code{getnstr} is equivalent to a series of calls to
@code{getch}, until a newline or carriage return is received (the
terminating character is not included in the returned string).  The
resulting string is returned.

@code{getnstr} reads at most @var{n} characters, thus preventing a
possible overflow of the input buffer.  Any attempt to enter more
characters (other than the terminating newline or carriage return)
causes a beep.  Function keys also cause a beep and are ignored.

The user's erase and kill characters are interpreted. If keypad mode
is on for the window, @code{KEY_LEFT} and @code{KEY_BACKSPACE} are
both considered equivalent to the user's kill character.

Characters input are echoed only if @code{echo!} is currently on.  In
that case, backspace is echoed as deletion of the previous character
(typically a left motion).

If a SIGWINCH interrupts the function, it will return the integer
value of KEY_RESIZE instead of a string.
@end deffn

@node Cursor location and window coordinates, Getting a rendered character from the window, Receiving strings from the keyboard, The basic curses library
@subsection Cursor location and window coordinates

@deffn Procedure getyx win
@deffnx Procedure getcurx win
@deffnx Procedure getcury win
The @code{getyx} procedure returns the current cursor position as a
list containing two integers.  The first is the y position and the
second is the x position.

The other two procedures return the x y positions respectively.
@end deffn

@deffn Procedure getparyx win
@deffnx Procedure getparx win
@deffnx Procedure getpary win
If @var{win} is a subwindow, the @code{getparyx} procedure places the
beginning coordinates of the subwindow relative to the parent window
into two element list @code{(y x)}.  Otherwise, @code{(-1 -1)} is
returned.

The other two procedures return the x and y respectively.
@end deffn

@deffn Procedure getbegyx win
@deffnx Procedure getbegx win
@deffnx Procedure getbegy win
The procedure @code{getbegyx} returns the beginning coordinates of a
window as two element list @code{(y x)}.
@end deffn

@deffn Procedure getmaxyx win
@deffnx Procedure getmaxx win
@deffnx Procedure getmaxy win
The procedure @code{getmaxyx} returns the size of a window as two
element list @code{(y x)}.
@end deffn

@node Getting a rendered character from the window, Getting a string of characters and attributes from a window, Cursor location and window coordinates, The basic curses library
@subsection Getting a rendered character from the window

These functions examine a character on the screen and return it, along
with its rendition.

@deffn Procedure inch

These routines return the rendered complex character at the current
position in the named window.
@end deffn


@node Getting a string of characters and attributes from a window, Input options, Getting a rendered character from the window, The basic curses library
@subsection Getting a string of characters and attributes from a window

@deffn Procedure inchnstr win #:key y x n

These routines return a list of rendered characters, starting at the
current cursor position in the named window and ending at the right
margin of the window or until @var{n} characters have been found.
@end deffn

@node Input options, Inserting a character before the cursor, Getting a string of characters and attributes from a window, The basic curses library
@subsection Input options

@deffn Procedure cbreak!
@deffnx Procedure nocbreak!
@cindex Line buffering
@cindex Control character processing

Normally, the TTY driver buffers typed characters until a @key{NL} or
@key{RET} is typed.  The @code{cbreak!} routine disables line
buffering and erase/kill character processing (interrupt and flow
control characters are unaffected), making characters typed by the
user immediately available to the program.

The @code{nocbreak!} routine returns the terminal to normal (cooked)
mode.

These routines will return @code{#t} on success and @code{#f} on
failure.  Failure may indicate that the underlying screen data is
invalid.  The routine may also fail if @code{cbreak!} was called on an
ordinary file (such as might be used with @code{newterm}) instead of a
TTY.

@findex raw!
@findex getch

Initially the terminal may or may not be in @code{cbreak} mode, as the
mode is inherited; therefore, a program should call @code{cbreak!} or
@code{nocbreak!} explicitly.  Most interactive programs using curses
set the @code{cbreak!} mode.  Note that @code{cbreak!} overrides
@code{raw!}.

@end deffn

@deffn Procedure echo!
@deffnx Procedure noecho!
@cindex Echoing

The @code{echo!} and @code{noecho!} routines control whether
characters typed by the user are echoed by getch as they are typed.
Echoing by the TTY driver is always disabled, but initially
@code{getch} is in echo mode, so characters typed are echoed.  Authors
of most interactive programs prefer to do their own echoing in a
controlled area of the screen, or not to echo at all, so they disable
echoing by calling @code{noecho!}.  See @ref{Getting characters from
the keyboard} for a discussion of how these routines interact with
@code{echo!} and @code{noecho!}.

The return values are unspecified.

@end deffn


@deffn Procedure halfdelay! tenths
@cindex Half-delay mode
@cindex Line buffering

@findex cbreak!
@findex nocbreak!

The @code{halfdelay!} routine is used for half-delay mode, which is similar to
@code{cbreak!} mode in that characters typed by the user are immediately
available to the program.  However, after blocking for @var{tenths} tenths
of seconds, @code{#f} is returned if nothing has been typed.  The value of
tenths must be a number between 1 and 255.  Use @code{nocbreak!} to leave
half-delay mode.

The return value is unspecified.

@end deffn

@deffn Procedure intrflush! bf

If the intrflush option is enabled, (@var{bf} is @code{#t}), when an
interrupt key is pressed on the keyboard (interrupt, break, quit) all
output in the TTY driver queue will be flushed, giving the effect of
faster response to the interrupt, but causing curses to have the wrong
idea of what is on the screen.  Disabling (@var{bf} is @code{#f}), the
option prevents the flush.  The default for the option is inherited
from the TTY driver settings.

The return value is unspecified.

@end deffn


@deffn Procedure keypad! win bf

@findex wgetch

The keypad! option enables the keypad of the user's terminal.  If
enabled (@var{bf} is @code{#t}), the user can press a function key
(such as an arrow key) and @code{getch} returns a single value
representing the function key, as in @code{KEY_LEFT}. If disabled
(@var{bf} is @code{#f}), curses does not treat function keys specially
and the program has to interpret the escape sequences itself.  If the
keypad in the terminal can be turned on (made to transmit) and off
(made to work locally), turning on this option causes the terminal
keypad to be turned on when @code{getch} is called.  The default value
for keypad is @code{#f}.

The return value is unspecified.  This procedure could throw a ``bad
state'' error.

@end deffn


@deffn Procedure meta! bf
@cindex 7-bit characters
@cindex 8-bit characters

If Guile-Ncurses was compiled with the standard version of the ncurses
library, and not the wide version, it operates on 8-bit characters.

Initially, whether the terminal returns 7 or 8 significant bits on
input depends on the control mode of the TTY driver.  To force 8 bits
to be returned, invoke @code{(meta! #t)}.  This is equivalent,
under POSIX, to setting the CS8 flag on the terminal.  To force 7 bits
to be returned, invoke @code{(meta! #f)}.  This is equivalent,
under POSIX, to setting the CS7 flag on the terminal.  The window
argument, @var{win}, is always ignored. If the terminfo capabilities
@code{smm} (@code{meta-on}) and @code{rmm} (@code{meta-off}) are
defined for the terminal.  The code for @code{smm} is sent to the
terminal when @code{(meta! #t)} is called and @code{rmm} is sent
when @code{(meta! #f)} is called.

The return value is unspecified.
@end deffn

@deffn Procedure nodelay! win bf
@cindex Blocking
@cindex Input, blocking
@findex getch

The @code{nodelay!} option causes @code{getch} to be a non-blocking
call.  If no input is ready, getch returns @code{#f}.  If disabled
(@var{bf} is @code{#f}), @code{getch} waits until a key is pressed.

The return value is unspecified.
@end deffn

@deffn Procedure notimeout! win bf

@findex getch
While interpreting an input escape sequence, @code{getch} sets a timer
while waiting for the next character. If @code{(notimeout! win #t)} is
called, then @code{getch} does not set a timer.  The purpose of the
timeout is to differentiate between sequences received from a function
key and those typed by a user.

The return value is unspecified.
@end deffn

@deffn Procedure raw!
@deffnx Procedure noraw!
@cindex Control character processing
@cindex Line buffering

The @code{raw!} and @code{noraw!} routines place the terminal into or
out of raw mode.  Raw mode is similar to @code{cbreak!} mode, in that
characters typed are immediately passed through to the user program.
The differences are that in raw mode, the interrupt, quit, suspend,
and flow control characters are all passed through uninterpreted,
instead of generating a signal.  The behavior of the @key{BREAK} key depends
on other bits in the TTY driver that are not set by curses.

The return value is unspecified.

@end deffn

@deffn Procedure noqiflush!
@deffnx Procedure qiflush!
@cindex Flushing
@cindex Input, flushing
@cindex Output, flushing

When the @code{noqiflush!} routine is used, normal flush of input and
output queues associated with the INTR, QUIT and SUSP characters will
not be done.  When @code{qiflush!} is called, the queues will be
flushed when these control characters are read. You may want to call
@code{noqiflush!} in a signal handler if you want output to continue as
though the interrupt had not occurred, after the handler exits.

The return value is unspecified.
@end deffn

@deffn Procedure timeout! win delay
@cindex Blocking
@cindex Input, blocking
@findex nodelay!

The @code{timeout!} routine sets blocking or non-blocking read for a
given window.  If @var{delay} is negative, blocking read is used
(i.e., waits indefinitely for input).  If @var{delay} is zero, then
non-blocking read is used (i.e., read returns @code{#f} if no input is
waiting).  If @var{delay} is positive, then read blocks for delay
milliseconds, and returns @code{#f} if there is still no input. Hence,
these routines provide the same functionality as @code{nodelay!}, plus
the additional capability of being able to block for only @var{delay}
milliseconds (where @var{delay} is positive).

@end deffn


@deffn Procedure typeahead! fd

The curses library does ``line-breakout optimization'' by looking for
typeahead periodically while updating the screen.  If input is found,
and it is coming from a TTY, the current update is postponed until
refresh or doupdate is called again.  This allows faster response to
commands typed in advance.  Normally, the input file port passed to
newterm, or @code{stdin} in the case that initscr was used, will be
used to do this typeahead checking.  The @code{typeahead!} routine
specifies that the (integer) file descriptor @var{fd} is to be used to
check for typeahead instead.  If @var{fd} is -1, then no typeahead
checking is done.

The routine returns @code{#t} if the mode could be set and @code{#f}
on failure.
@end deffn

There are a set of procedures to test the input options of a given window.

@deffn Procedure is-keypad? win
@deffnx Procedure is-meta? win
@deffnx Procedure is-nodelay? win
@deffnx Procedure is-immedok? win
@deffnx Procedure is-notimeout? win

These test the input options of the window @var{win} and return
@code{#t} if they are set.
@end deffn


@node Inserting a character before the cursor, Inserting a string before the cursor, Input options, The basic curses library
@subsection Inserting a character before the cursor

@deffn Procedure insch win ch #:key y x

These routines insert the character @var{ch} before the character
under the cursor.  All characters to the right of the cursor are moved
one space to the right, with the possibility of the rightmost
character on the line being lost.  The insertion operation does not
change the cursor position.

It returns @code{#f} upon failure and @code{#t} upon successful
completion.

@end deffn

@node Inserting a string before the cursor, Getting a string of characters from the screen, Inserting a character before the cursor, The basic curses library
@subsection Inserting a string before the cursor

@deffn Procedure insstr win str #:key y x n

This routine inserts a character string (as many characters as will
fit on the line) before the character under the cursor. All characters
to the right of the cursor are shifted right with the possibility of
the rightmost characters on the line being lost.  The cursor position
does not change (after moving to @var{y}, @var{x}, if specified). If
@var{n} is specified, it inserts a leading substring of at most n
characters, or if @var{n}<=0, then the entire string is inserted.

@findex addch

Special characters are handled as in @code{addch}.

It returns @code{#f} upon failure and @code{#t} upon successful
completion.

@end deffn

@node Getting a string of characters from the screen, Low-level routines, Inserting a string before the cursor, The basic curses library
@subsection Getting a string of characters from the screen

@deffn Procedure instr win #:key y x n

This routine returns a unrendered string, extracted starting at the
current cursor position in the named window. Attributes are stripped
from the characters.  If @var{n} is specified, it returns a leading
substring at most @var{n} characters long.

@end deffn

@node Low-level routines, Mouse handling, Getting a string of characters from the screen, The basic curses library
@subsection Low-level routines

The following routines give low-level access to various curses
capabilities.  Theses routines typically are used inside library
routines.

@deffn Procedure def-prog-mode
@deffnx Procedure def-shell-mode

@findex initscr
@findex newterm
@cindex Terminal modes, saving

The @code{def-prog-mode} and @code{def-shell-mode} routines save the
current terminal modes as the "program" (in curses) or "shell" (not in
curses) state for use by the @code{reset-prog-mode} and
@code{reset-shell-mode} routines.  This is done automatically by
@code{initscr}.  There is one such save area for each screen context
allocated by @code{newterm}.

They return @code{#t} on success and @code{#f} on failure.

@end deffn


@deffn Procedure reset-prog-mode
@deffnx Procedure reset-shell-mode
@cindex Curses, ending
@cindex Terminal modes
@findex endwin
@findex doupdate

The @code{reset-prog-mode} and @code{reset-shell-mode} routines
restore the terminal to "program" (in curses) or "shell" (out of
curses) state.  These are done automatically by @code{endwin} and,
after an @code{endwin}, by @code{doupdate}, so they normally are not
called.

Returns @code{#t} on success or @code{#f} on failure.  Failure could
indicate that this terminal was created with @code{newterm} and thus
doesn't have a previous state.

@end deffn

@deffn Procedure resetty
@deffnx Procedure savetty
@cindex Terminal modes

The @code{resetty} and @code{savetty} routines save and restore the
state of the terminal modes.  @code{savetty} saves the current state
in a buffer and @code{resetty} restores the state to what it was at
the last call to @code{savetty}.

Returns @code{#t} on success or @code{#f} on failure.  Failure could
indicate that this terminal was created with @code{newterm} and thus
doesn't have a previous state.
@end deffn

@deffn Procedure curs-set visibility
@cindex Cursor, hiding
@cindex Cursor, visiblity

The @code{curs-set} routine changes the visibility of the cursor.  If
@var{visibility} is 0, the cursor is set to invisible.  For 1, the
cursor is visible.  For 2, the cursor is very visible.  If the
terminal supports the visibility requested, the previous cursor state
is returned; otherwise, @code{#f} is returned.

@end deffn

@deffn Procedure napms ms

The procedure is used to sleep for @var{ms} milliseconds.

The return value is unspecified.
@end deffn

@node Mouse handling, Moving the cursor , Low-level routines, The basic curses library
@subsection Mouse handling

These functions provide an interface to mouse events.
Mouse events are represented by @code{KEY_MOUSE} pseudo-key values in the
@code{wgetch} input stream.

To make mouse events visible, use the @code{mousemask} function.

@deffn Procedure has-mouse?
Returns @code{#t} if the mouse driver has been successfully installed.
@end deffn

@deffn Procedure mousemask mask

This will set the mouse events to be reported.  By default, no mouse
events are reported.  The function will return a mask to indicate
which of the specified mouse events can be reported; on complete
failure it returns 0.

As a side effect, setting a zero mousemask may turn off the mouse
pointer; setting a nonzero mask may turn it on.  Whether this happens
is device-dependent.

See @ref{tab:mouse} for the mouse event types mask that may be defined.
@end deffn


@float Table,tab:mouse
@multitable {BUTTONX_DOUBLE_CLICKED} {control was down during button state change XX}
@headitem name @tab description

@item @code{BUTTON1_PRESSED} @tab mouse button 1 down
@item @code{BUTTON1_RELEASED} @tab mouse button 1 up
@item @code{BUTTON1_CLICKED} @tab mouse button 1 clicked
@item @code{BUTTON1_DOUBLE_CLICKED} @tab mouse button 1 double clicked
@item @code{BUTTON1_TRIPLE_CLICKED} @tab mouse button 1 triple
clicked
@item
@item @code{BUTTON2_PRESSED} @tab mouse button 2 down
@item @code{BUTTON2_RELEASED} @tab mouse button 2 up
@item @code{BUTTON2_CLICKED} @tab mouse button 2 clicked
@item @code{BUTTON2_DOUBLE_CLICKED} @tab mouse button 2 double clicked
@item @code{BUTTON2_TRIPLE_CLICKED} @tab mouse button 2 triple clicked
@item
@item @code{BUTTON3_PRESSED} @tab mouse button 3 down
@item @code{BUTTON3_RELEASED} @tab mouse button 3 up
@item @code{BUTTON3_CLICKED} @tab mouse button 3 clicked
@item @code{BUTTON3_DOUBLE_CLICKED} @tab mouse button 3 double clicked
@item @code{BUTTON3_TRIPLE_CLICKED} @tab mouse button 3 triple clicked
@item
@item @code{BUTTON4_PRESSED} @tab mouse button 4 down
@item @code{BUTTON4_RELEASED} @tab mouse button 4 up
@item @code{BUTTON4_CLICKED} @tab mouse button 4 clicked
@item @code{BUTTON4_DOUBLE_CLICKED} @tab mouse button 4 double clicked
@item @code{BUTTON4_TRIPLE_CLICKED} @tab mouse button 4 triple clicked
@item
@item @code{BUTTON5_PRESSED} @tab mouse button 5 down
@item @code{BUTTON5_RELEASED} @tab mouse button 5 up
@item @code{BUTTON5_CLICKED} @tab mouse button 5 clicked
@item @code{BUTTON5_DOUBLE_CLICKED} @tab mouse button 5 double clicked
@item @code{BUTTON5_TRIPLE_CLICKED} @tab mouse button 5 triple clicked
@item
@item @code{BUTTON_SHIFT} @tab shift was down during button state
change
@item @code{BUTTON_CTRL} @tab control was down during button state
change
@item @code{BUTTON_ALT} @tab alt was down during button state change
@item @code{ALL_MOUSE_EVENTS} @tab report all button state changes
@item @code{REPORT_MOUSE_POSITION} @tab report mouse movement
@end multitable
@caption{Mouse mask constants}
@end float

Once a class of mouse events have been made visible in a window,
calling the @code{wgetch} function on that window may return
@code{KEY_MOUSE} as an indicator that a mouse event has been queued.
To read the event data and pop the event off the queue, call
@code{getmouse}.

@deffn Procedure getmouse
This will return either a list of mouse information, or @code{#f}.  If
it does return a list, it will have the following form:
@example
(id                             ; @r{id to distinguish multiple devices}
x y z                           ; @r{event coordinates}
bstate)                         ; @r{button state bits}
@end example

When @code{getmouse} returns a list, the data deposited as y and x in
the list will be screen-relative character-cell coordinates.  The
returned state mask will have exactly one bit set to indicate the
event type.

@end deffn

@deffn Procedure ungetmouse mouse-event

The @code{ungetmouse} function behaves analogously to @code{ungetch}.
It pushes a @code{KEY_MOUSE} event onto the input queue, and
associates with that event the given state data and screen-relative
character-cell coordinates in the @var{mouse-event} list, where
@var{mouse-event} is a list of five elements as described above.

@end deffn

@deffn Procedure mouse-trafo win y x to-screen

@findex slk-init

The @code{mouse-trafo} function transforms a given pair of
coordinates @var{y}, @var{x} from @code{stdscr}-relative coordinates
to coordinates relative to the given window @var{win} or vice versa.
Please remember, that @code{stdscr}-relative coordinates are not
always identical to window-relative coordinates due to the mechanism
to reserve lines on top or bottom of the screen for other purposes
(see @code{slk-init}, for example).  If the parameter @var{to-screen}
is @code{#t}, the procedure returns either a list of two elements
(@code{y}, @code{x}) which is the location inside the window
@var{win}, or @code{#f} if the location was not inside the window.  If
@var{to-screen} is @code{#f}, the return a list of two elements of
where the window-relative location @var{y}, @var{x} would be in
stdscr-relative coordinates.

The @code{mouse-trafo} procedure performs the same translation as
@code{wmouse-trafo}, using @code{stdscr} for @var{win}.
@end deffn

@deffn Procedure wenclose? win y x

The @code{wenclose?} function tests whether a given pair of
screen-relative character-cell coordinates is enclosed by the given
window @var{win}, returning @code{#t} if it is and @code{#f}
otherwise.  It is useful for determining what subset of the screen
windows enclose the location of a mouse event.

@end deffn


@deffn Procedure mouseinterval erval

The @code{mouseinterval} function sets the maximum time (in thousands of a
second) that can elapse between press and release events for them to
be recognized as a click.  Use @code{(mouseinterval 0)} to disable click
resolution.  This function returns the previous interval value.  Use
@code{(mouseinterval -1)} to obtain the interval without altering it.  The
default is one sixth of a second.
@end deffn

@node Moving the cursor , Output options, Mouse handling, The basic curses library
@subsection Moving the cursor

@deffn Procedure move win y x

@findex refresh

This routine moves the cursor associated with the window to line
@var{y} and column @var{x}.  This routine does not move the physical
cursor of the terminal until @code{refresh} is called.  The position
specified is relative to the upper left-hand corner of the window,
which is @code{(0 0)}.

It returns @code{#f} upon failure and @code{#t} on successful
completion.

@end deffn

@node Output options, Overlay and manipulate overlapped windows, Moving the cursor , The basic curses library
@subsection Output options


These routines set options that change the style of output within
curses.  All options are initially @code{#f}, unless otherwise stated.  It
is not necessary to turn these options off before calling @code{endwin}.

@deffn Procedure clearok! win bf
@cindex Erasing the screen
@cindex Clearing the screen
@cindex Screens, clearing
@cindex Screens, erasing
@findex refresh

If @code{clearok!} is called with @var{bf} as @code{#t}, the next call
to @code{refresh} with this window will clear the screen completely
and redraw the entire screen from scratch.  This is useful when the
contents of the screen are uncertain, or in some cases for a more
pleasing visual effect.

@c If the @var{win} argument to
@c @code{clearok} is the global variable @code{curscr}, the next call to
@c @code{refresh} with any window causes the screen to be cleared and
@c repainted from scratch.

The return value is unspecified.

@end deffn

@deffn Procedure idlok! win bf

If @code{idlok!} is called with @code{#t} as second argument, curses
considers using the hardware insert/delete line feature of terminals
so equipped.  Calling @code{idlok!} with @var{bf} as @code{#f}
disables use of line insertion and deletion.  This option should be
enabled only if the application needs insert/delete line, for example,
for a screen editor.  It is disabled by default because insert/delete
line tends to be visually annoying when used in applications where it
isn't really needed.  If insert/delete line cannot be used, curses
redraws the changed portions of all lines.

The return value is unspecified.
@end deffn

@deffn Procedure idcok! win bf

If @code{idcok!} is called with @var{bf} as @code{#f}, curses no
longer considers using the hardware insert/delete character feature of
terminals so equipped.  Use of character insert/delete is enabled by
default.  Calling @code{idcok!} with @code{#t} as second argument
re-enables use of character insertion and deletion.

The return value is unspecified.
@end deffn


@deffn Procedure immedok! win bf
@cindex Updating automatically
@findex addch
@findex clrtobot
@findex wscrl
@findex refresh

If @code{immedok!} is called with @code{#t} as argument, any change in
the window image, such as the ones caused by @code{addch},
@code{clrtobot}, @code{scrl}, etc., automatically cause a call to
@code{refresh}.  However, it may degrade performance considerably,
due to repeated calls to @code{refresh}. It is disabled by default.

The return value is unspecified.
@end deffn

@deffn Procedure leaveok! win bf
@cindex Cursor, positioning

Normally, the hardware cursor is left at the location of the window
cursor being refreshed.  The @code{leaveok!} option allows the cursor
to be left wherever the update happens to leave it.  It is useful for
applications where the cursor is not used, since it reduces the need
for cursor motions.

@end deffn

@deffn Procedure setscrreg! win top bot
@cindex Scrolling
@findex scrollok!
@findex idlok!

The @code{setscrreg!} routine allows the application programmer to set
a software scrolling region in a window.  @var{top} and @var{bot} are
the line numbers of the top and bottom margin of the scrolling region.
(Line 0 is the top line of the window.)  If this option and
@code{scrollok!} are enabled, an attempt to move off the bottom margin
line causes all lines in the scrolling region to scroll one line in
the direction of the first line. Only the text of the window is
scrolled.  (Note that this has nothing to do with the use of a
physical scrolling region capability in the terminal, like that in the
VT100.  If @code{idlok!} is enabled and the terminal has either a
scrolling region or insert/delete line capability, they will probably
be used by the output routines.)
@end deffn

@deffn Procedure getscrreg win
Returns a two-element list that contains the line numbers of the top and
bottom of the scroll region for the window @var{win}.
@end deffn

@deffn Procedure scrollok! win bf
@cindex Scrolling
@findex idlok!

The @code{scrollok!} option controls what happens when the cursor of a window
is moved off the edge of the window or scrolling region, either as a
result of a newline action on the bottom line, or typing the last
character of the last line. If disabled, (@var{bf} is @code{#f}), the cursor
is left on the bottom line.  If enabled, (@var{bf} is @code{#t}), the window is
scrolled up one line (Note that to get the physical scrolling effect
on the terminal, it is also necessary to call @code{idlok!}).

The return value is unspecified.
@end deffn

@deffn Procedure nl!
@deffnx Procedure nonl!
@cindex Carriage return
@cindex Line feed

The @code{nl!} and @code{nonl!} routines control whether the underlying
display device translates @key{RET} (return) into @key{NL} (newline)
on input, and whether it translates @key{NL} into @key{RET} and
@key{LF} (linefeed) output (in either case, the call @code{(addch
(normal #\nl))} does the equivalent of return and line feed on
the virtual screen).  Initially, these translations do occur.  If you
disable them using @code{nonl!}, curses will be able to make better use
of the line-feed capability, resulting in faster cursor motion.  Also,
curses will then be able to detect the return key.

The return values are unspecified;

@end deffn

There are a set of procedures to test the output options of a given window.

@deffn Procedure is-cleared? win
@deffnx Procedure is-idlok? win
@deffnx Procedure is-idcok? win
@deffnx Procedure is-immedok? win
@deffnx Procedure is-leaveok? win
@deffnx Procedure is-scrollok? win

These test the output options of the window @var{win} and return
@code{#t} if they are set.
@end deffn

@node Overlay and manipulate overlapped windows, Create and display pads, Output options, The basic curses library
@subsection Overlay and manipulate overlapped windows


@deffn Procedure overlay srcwin dstwin
@deffnx Procedure overwrite srcwin dstwin
@cindex Overlaying
@cindex Windows, overlaying


The @code{overlay} and @code{overwrite} routines overlay @var{srcwin}
on top of @var{dstwin}.  @var{scrwin} and @var{dstwin} are not
required to be the same size; only text where the two windows overlap
is copied.  The difference is that overlay is non-destructive (blanks
are not copied) whereas overwrite is destructive.

The return values are unspecified.
@end deffn

@deffn Procedure copywin srcwin dstwin sminrow smincol dminrow dmincol dmaxrow dmaxcol overlay
@cindex Copying windows
@cindex Overlaying windows
@cindex Windows, copying
@cindex Windows, overlaying
@findex overlay
@findex overwrite
@findex prefresh

The @code{copywin} routine provides a finer granularity of control
over the @code{overlay} and @code{overwrite} routines.  Like in the
@code{prefresh} routine, a rectangle is specified in the destination
window, (@var{dminrow}, @var{dmincol}) and (@var{dmaxrow},
@var{dmaxcol}), and the upper-left-corner coordinates of the source
window, (@var{sminrow}, @var{smincol}).  If the argument @var{overlay}
is @code{#t}, then copying is non-destructive, as in overlay.

Returns @code{#t} on success or @code{#f} on failure.  @code{#f} could
indicate that some part of the window would be placed offscreen.
@end deffn

@node Create and display pads, Print data to a terminal-attached ports, Overlay and manipulate overlapped windows, The basic curses library
@subsection Create and display pads
@cindex Pads
@cindex Pads, creating
@findex pnoutrefresh
@findex refresh
@findex prefresh

A pad is like a window, except that it is not restricted by the screen
size, and is not necessarily associated with a particular part of the
screen. Pads can be used when a large window is needed, and only a
part of the window will be on the screen at one time.  Automatic
refreshes of pads (e.g., from scrolling or echoing of input) do not
occur.  It is not legal to call @code{refresh} with a pad as an
argument; the routines @code{prefresh} or @code{pnoutrefresh} should
be called instead.  Note that these routines require additional
parameters to specify the part of the pad to be displayed and the
location on the screen to be used for the display.

@deffn Procedure newpad nlines ncols
@cindex Pads, creating

The newpad routine creates and returns @code{#<window>} pad with the
given number of lines, @var{nlines}, and columns, @var{ncols}.

@end deffn

@findex %is-pad-broken
@deffn Procedure is-pad? win
Returns @code{#t} if @var{win} is a pad.  @code{#f} otherwise.

If the underlying ncurses implementation is not capable of reporting
whether a window is a pad, this function will always return @code{#t}.
This can happen in older versions of ncurses that were compiled with
the @code{NCURSES_OPAQUE} option enabled.

To see if this @code{is-pad?} procedure actually works, you can check
the constant @code{%is-pad-broken}, which will be #f is @code{is-pad?}
actually works.
@end deffn


@deffn Procedure subpad orig nlines ncols begin-y begin-x
@cindex Pads
@findex subwin
@findex touchwin
@findex touchline
@findex prefresh
@findex subwin

The @code{subpad} routine creates and returns a pointer to a subwindow
within a pad with the given number of lines, @var{nlines}, and
columns, @var{ncols}.  Unlike @code{subwin}, which uses screen
coordinates, the window is at position (@var{begin-x}, @var{begin-y})
on the pad.  The window is made in the middle of the window orig, so
that changes made to one window affect both windows.  During the use
of this routine, it will often be necessary to call @code{touchwin} or
@code{touchline} on orig before calling @code{prefresh}.

@end deffn


@deffn Procedure prefresh pad pminrow pmincol sminrow simincol smaxrow smaxcol
@deffnx Procedure pnoutrefresh pad pminrow pmincol sminrow smincol smaxrow smaxcol
@cindex Pads, refreshing
@findex refresh
@findex noutrefresh

The @code{prefresh} and @code{pnoutrefresh} routines are analogous to
@code{refresh} and @code{noutrefresh} except that they relate to pads
instead of windows.  The additional parameters are needed to indicate
what part of the pad and screen are involved.  @var{pminrow} and
@code{pmincol} specify the upper left-hand corner of the rectangle to
be displayed in the pad.  @var{sminrow}, @var{smincol}, @var{smaxrow},
and @var{smaxcol} specify the edges of the rectangle to be displayed
on the screen.  The lower right-hand corner of the rectangle to be
displayed in the pad is calculated from the screen coordinates, since
the rectangles must be the same size.  Both rectangles must be
entirely contained within their respective structures.  Negative
values of @var{pminrow}, @var{pmincol}, @var{sminrow}, or
@var{smincol} are treated as if they were zero.

Returns @code{#f} upon failure and @code{#t} upon successful
@end deffn


@deffn Procedure pechochar pad ch
@cindex Outputting characters
@findex addch
@findex refresh
@findex prefresh

The @code{pechochar} routine is functionally equivalent to a call to
@code{addch} followed by a call to @code{refresh} or a call to
@code{addch} followed by a call to @code{prefresh}.  The knowledge
that only a single character is being output is taken into
consideration and, for non-control characters, a considerable
performance gain might be seen by using these routines instead of
their equivalents.  In the case of @code{pechochar}, the last location
of the pad on the screen is reused for the arguments to
@code{prefresh}.

Returns @code{#f} upon failure and @code{#t} upon successful
completion.
@end deffn

@node Print data to a terminal-attached ports, Refresh windows and lines, Create and display pads, The basic curses library
@subsection Print data to a terminal-attached ports

Some old-school hardware terminals had serial or parallel ports
attached to them.  There is a procedure to send data to those ports.
Usually those ports were used for old serial dot-matrix printers.  This
function is likely obsolete.

@deffn Procedure mcprint str
This procedure takes the given @var{str}, converts it into a byte stream
using the current locale, and then sends the data to a terminal's
printer port.  A terminal that has a printer port must terminfo
information that describes it, such as @emph{mc5p} or @emph{mc4}
capabilities.  Explaining this is beyond the scope of this library.

Those hardware terminal ports and the printers that used them were slow,
and the application must take the responsibility to not flood the port.

The procedure returns @code{#f} if the write fails.  Otherwise, it
returns the number of bytes actually printed.
@end deffn

@node Refresh windows and lines, Reading and writing a curses screen to a file, Print data to a terminal-attached ports, The basic curses library
@subsection Refresh windows and lines

@deffn Procedure refresh win

@findex noutrefresh
@findex doupdate
@findex leaveok!

The @code{refresh} routine (or @code{noutrefresh} and
@code{doupdate}) must be called to get actual output to the terminal,
as other routines merely manipulate data structures.  The routine
@code{refresh} copies the named window to the physical terminal
screen, taking into account what is already there to do optimizations.
The @code{refresh} routine is the same, using @code{stdscr} as the
default window.  Unless @code{leaveok!} has been enabled, the physical
cursor of the terminal is left at the location of the cursor for that
window.

@end deffn


@deffn Procedure noutrefresh win

Copies the named window @var{win} to the virtual screen

@end deffn

@deffn Procedure doupdate

Compares the virtual screen to the physical screen and updates it
where necessary.

@end deffn

The @code{noutrefresh} and @code{doupdate} routines allow multiple
updates with more efficiency than @code{refresh} alone. In addition
to all the window structures, curses keeps two data structures
representing the terminal screen: a physical screen, describing what
is actually on the screen, and a virtual screen, describing what the
programmer wants to have on the screen.

The routine @code{refresh} works by first calling
@code{noutrefresh}, which copies the named window to the virtual
screen, and then calling @code{doupdate}, which compares the virtual
screen to the physical screen and does the actual update.  If the
programmer wishes to output several windows at once, a series of calls
to @code{refresh} results in alternating calls to @code{noutrefresh}
and @code{doupdate}, causing several bursts of output to the
screen. By first calling @code{noutrefresh} for each window, it is
then possible to call @code{doupdate} once, resulting in only one
burst of output, with fewer total characters transmitted and less CPU
time used. If the @var{win} argument to @code{refresh} is the global
variable @code{curscr}, the screen is immediately cleared and
repainted from scratch.

The phrase "copies the named window to the virtual screen" above is
ambiguous.  What actually happens is that all touched (changed) lines
in the window are copied to the virtual screen.  This affects programs
that use overlapping windows; it means that if two windows overlap,
you can refresh them in either order and the overlap region will be
modified only when it is explicitly changed.

@deffn Procedure redrawwin win
@deffnx Procedure redrawln win beg-line num-lines
@cindex Redrawing
@cindex Windows, redrawing

The @code{redrawln} routine indicates to curses that some screen
lines are corrupted and should be thrown away before anything is
written over them.  It touches the indicated lines (marking them
changed).  The routine @code{redrawwin} touches the entire window.

Returns @code{#t} on success and @code{#f} on failure.

@end deffn

@node Reading and writing a curses screen to a file, Scroll a window, Refresh windows and lines, The basic curses library
@subsection Reading and writing a curses screen to a file

@deffn Procedure scr-dump filename
@cindex Curses, dumping to disk
@cindex Dumping to disk
The @code{scr-dump} routine dumps the current contents of the virtual screen
to the file @var{filename}.

@end deffn


@deffn Procedure scr-restore filename
@cindex Writing to disk

@findex doupdate

The @code{scr-restore} routine sets the virtual screen to the contents
of @var{filename}, which must have been written using scr-dump.  The
next call to @code{doupdate} restores the screen to the way it looked
in the dump file.

@end deffn

@deffn Procedure scr-init filename

@findex initscr
@findex scr-dump
@findex endwin

The @code{scr-init} routine reads in the contents of @var{filename}
and uses them to initialize the curses data structures about what the
terminal currently has on its screen.  If the data is determined to be
valid, curses bases its next update of the screen on this information
rather than clearing the screen and starting from scratch.
@code{scr-init} is used after @code{initscr} or a system call to share
the screen with another process which has done a @code{scr-dump} after
its @code{endwin} call.  The data is declared invalid if the terminfo
capabilities @code{rmcup} and @code{nrrmc} exist; also if the terminal
has been written to since the preceding @code{scr-dump} call.

@end deffn

@deffn Procedure scr-set filename

@findex scr-restore
@findex scr-init

The @code{scr-set} routine is a combination of @code{scr-restore} and
@code{scr-init}.  It tells the program that the information in
@var{filename} is what is currently on the screen, and also what the
program wants on the screen.  This can be thought of as a screen
inheritance function.

@end deffn

@findex getwin
@findex putwin

To read (write) a window from (to) a file, use the @code{getwin} and
@code{putwin} routines.

All routines return the integer @code{#f} upon failure and @code{#t}
upon success.

@node Scroll a window, Terminal attributes, Reading and writing a curses screen to a file, The basic curses library
@subsection Scroll a window

@deffn Procedure scroll win

The @code{scroll} routine scrolls the window up one line.  This
involves moving the lines in the window data structure.  As an
optimization, if the scrolling region of the window is the entire
screen, the physical screen may be scrolled at the same time.

@end deffn


@deffn Procedure scrl win n
@cindex Scrolling
@findex scrollok!

For positive @var{n}, the @code{scrl} and @code{wscrl} routines scroll
the window up @code{n} lines (line i+n becomes i); otherwise scroll
the window down @code{n} lines.  This involves moving the lines in the
window character image structure.  The current cursor position is not
changed.

For these functions to work, scrolling must be enabled via
@code{scrollok!}.

It returns @code{#f} upon failure, and @code{#t} upon
successful completion.

@end deffn


@node Terminal attributes, Refresh routines, Scroll a window, The basic curses library
@subsection Terminal attributes


@deffn Procedure baudrate
@cindex Terminal, baudrate
@cindex Baudrate

The @code{baudrate} routine returns the output speed of the terminal.
The number returned is in bits per second, for example 9600, and is an
integer.  It could return @code{#f} if this screen is no longer valid.

@end deffn

@deffn Procedure erasechar

The erasechar routine returns the user's current erase character.  If
the terminal is a dumb terminal and has no erase character, it will
return @code{#f}.

@end deffn

@deffn Procedure has-ic?
@cindex Insert character
@cindex Terminal capabilities, insert

The @code{has-ic?} routine is true if the terminal has insert- and
delete- character capabilities.

@end deffn

@deffn Procedure has-il?
@cindex Insert lines
@cindex Terminal capabilities, insert

@findex scrollok!

The @code{has-il?} routine is true if the terminal has insert- and
delete-line capabilities, or can simulate them using scrolling
regions.  This might be used to determine if it would be appropriate
to turn on physical scrolling using @code{scrollok!}.

@end deffn

@deffn Procedure killchar

The killchar routine returns the user's current line kill character.
If the terminal has no killchar, it will return @code{#f}.

@end deffn

@deffn Procedure longname

The @code{longname} routine returns a string that is a
verbose description of the current terminal.

@end deffn

@deffn Procedure termattrs
@findex term-attrs

The @code{termattrs} function return a @code{logior} of all video
attributes supported by the terminal using the standard @code{A_XXX}
constants.  The @code{term-attrs} function is nearly identical, except
that it tests rarely used attributes that might someday having to do
with wide characters: @code{A_HORIZONTAL}, @code{A_LEFT},
@code{A_LOW}, @code{A_RIGHT}, @code{A_TOP}, and @code{A_VERTICAL}.

@end deffn

@deffn Procedure termname

The @code{termname} routine returns the terminal name used by
@code{setupterm}.

@end deffn

@node Refresh routines, Miscellaneous utilities, Terminal attributes, The basic curses library
@subsection Refresh routines

@deffn Procedure touchwin win
@deffnx Procedure touchline win start count

The @code{touchwin} and @code{touchline} routines throw away all
optimization information about which parts of the window have been
touched, by pretending that the entire window has been drawn on.  This
is sometimes necessary when using overlapping windows, since a change
to one window affects the other window, but the records of which lines
have been changed in the other window do not reflect the change.  The
routine @code{touchline} only pretends that @var{count} lines have
been changed, beginning with line @var{start}.

@end deffn

@deffn Procedure is-linetouched? win line

Returns @code{#t} if the specified window and line was modified since the
last call to @code{refresh}.

@end deffn

@deffn Procedure is-wintouched? win

Returns @code{#t} if the specified window was modified since the last call
to @code{refresh}>

@end deffn

@deffn Procedure untouchwin win

@findex refresh

The @code{untouchwin} routine marks all lines in the window as
unchanged since the last call to @code{refresh}.

@end deffn


@deffn Procedure wtouchln win y n changed

@findex refresh

The @code{wtouchln} routine makes @var{n} lines in the window,
starting at line @var{y}, look as if they have (@var{changed}=1) or have not
(@var{changed}=0) been changed since the last call to @code{refresh}.

@end deffn

@node Miscellaneous utilities, Window creation, Refresh routines, The basic curses library
@subsection Miscellaneous utilities

@deffn Procedure unctrl ch

The @code{unctrl} routine returns a character string which is a
printable representation of the character @var{ch}, ignoring
attributes.  Control characters are displayed in the @code{^X} notation.
Printing characters are displayed as is.

@end deffn

@deffn Procedure keyname ch
@cindex Key names

The @code{keyname} routine returns a character string corresponding to
the key @var{ch}.  Control characters are displayed in the @code{^X}
notation.  Values above 128 are either meta characters, shown in the
@code{M-X} notation, or the names of function keys, or null.

@end deffn

@deffn Procedure use-env f

@findex initscr

The @code{use-env} routine, if used, is called before @code{initscr}
or @code{newterm} are called. When called with @code{#f} as an
argument, the values of lines and columns specified in the terminfo
database will be used, even if environment variables @env{LINES} and
@env{COLUMNS} (used by default) are set, or if curses is running in a
window (in which case default behavior would be to use the window size
if LINES and COLUMNS are not set).  Note that setting @env{LINES} or
@env{COLUMNS} overrides the corresponding size which may be obtained
from the operating system.

@end deffn

@deffn Procedure putwin win file

@findex getwin

The @code{putwin} routine writes all data associated with window
@var{win} into the @code{#<file>} @var{file}.  This information can
be later retrieved using the @code{getwin} function.

@end deffn


@deffn Procedure getwin file

@findex putwin

The @code{getwin} routine reads window related data stored in the file
by @code{putwin}. The routine then creates and initializes a new
window using that data.  It returns a new @code{#<window>}

@end deffn

@deffn Procedure delay-output ms
@cindex Delaying output
@cindex Output, delaying

The @code{delay-output} routine inserts an @var{ms} millisecond pause
in output.  This routine should not be used extensively because
padding characters are used rather than a CPU pause.

The return value is unspecified.

@end deffn

@deffn Procedure flushinp
@cindex Flushing input
@cindex Input, flushing
@cindex Typeahead

The @code{flushinp} routine throws away any typeahead that has been
typed by the user and has not yet been read by the program.

The return value is unspecified.

@end deffn

@deffn Procedure curses-version
@cindex Ncurses, version information
@cindex Version information

Returns a string that indicates the version of ncurses being used, for
example ``ncurses 5.9''.

@end deffn

@deffn Procedure %filter

This procedure, when called before initscr, restricts the activity of
curses to a single line, instead of the to the entire screen.

@end deffn

@node Window creation,  , Miscellaneous utilities, The basic curses library
@subsection Window creation


@deffn Procedure newwin nlines ncols begin-y begin-x
@cindex Windows, creation

Calling @code{newwin} creates and returns a pointer to a new window
with the given number of lines and columns.  The upper left-hand
corner of the window is at line @var{begin-y}, column @var{begin-x}.
If either @var{nlines} or @var{ncols} is zero, they default to
@code{(- (lines) begin-y)} and @code{(- (cols) begin-x)}.  A new
full-screen window is created by calling @code{(newwin 0 0 0 0)}.

@end deffn

@deffn Procedure delwin win

Calling @code{delwin} deletes the named window, freeing all memory
associated with it (it does not actually erase the window's screen
image).  Subwindows must be deleted before the main window can be
deleted.

This function is called implicitly if a window is garbage collected.
@end deffn


@deffn Procedure mvwin win y x
@cindex Windows, moving

Calling @code{mvwin} moves the window so that the upper left-hand
corner is at position @var{x}, @var{y}.  If the move would cause the
window to be off the screen, it is an error and the window is not
moved.  Moving subwindows is allowed, but should be avoided.

The return value is unspecified;

@end deffn


@deffn Procedure subwin orig nlines ncols begin-y begin-x
@cindex Windows, derived
@cindex Subwindows

@findex touchwin
@findex touchline
@findex refresh

Calling @code{subwin} creates and returns a pointer to a new window
with the given number of lines, @var{nlines}, and columns,
@var{ncols}.  The window is at position (@var{begin-y}, @var{begin-x})
on the screen.  (This position is relative to the screen, and not to
the window orig.)  The window is made in the middle of the window
@var{orig}, so that changes made to one window will affect both
windows.  The subwindow shares memory with the window @var{orig}.
When using this routine, it is necessary to call @code{touchwin} or
@code{touchline} on @var{orig} before calling @code{refresh} on the
subwindow.

@end deffn

@findex %is-subwin-broken
@deffn Procedure is-subwin? win
Returns @code{#t} if @var{win} is a subwin.  Otherwise, @code{#f}.

If the underlying ncurses implementation is not capable of reporting
whether a window is a subwindow, this function will always return
@code{#t}.  This can happen in older versions of ncurses that were
compiled with the @code{NCURSES_OPAQUE} option enabled.

To see if this @code{is-subwin?} procedure actually works, you can check
the constant @code{%is-subwin-broken}, which will be #f is @code{is-subwin?}
actually works.
@end deffn

@deffn Procedure derwin orig nlines ncols begin-y begin-x
@cindex Windows, derived
@cindex Subwindows

Calling @code{derwin} is the same as calling @code{subwin}, except
that @var{begin-y} and @var{begin-x} are relative to the origin of the
window @var{orig} rather than the screen. There is no difference
between the subwindows and the derived windows.

It returns a window that shares memory with @var{orig}, or @code{#f}
if the window could not be created.
@end deffn


@deffn Procedure mvderwin win par-y par-x

Calling @code{mvderwin} moves a derived window (or subwindow) inside
its parent window.  The screen-relative parameters of the window are
not changed.  This routine is used to display different parts of the
parent window at the same physical position on the screen.

The return value is unspecified.

@end deffn


@deffn Procedure dupwin win
@cindex Windows, duplication

Calling @code{dupwin} returns a new window that is an exact duplicate
of the window @var{win}.

@end deffn

@deffn Procedure syncup win
@findex syncok!

Calling @code{syncup} touches all locations in ancestors of @var{win}
that are changed in @var{win}.  If @code{syncok!} is called with second
argument @code{#t} then @code{syncup} is called automatically
whenever there is a change in the window.

@end deffn

@deffn Procedure syncok! win bf

If @code{syncok!} is called with the second argument @code{#t} then
@code{syncup} is called automatically whenever there is a change in the
window.

The return value is unspecified.
@end deffn

@deffn Procedure syncdown win

@findex refresh

The @code{syncdown} routine touches each location in @var{win} that
has been touched in any of its ancestor windows. This routine is
called by @code{refresh}, so it should almost never be necessary to
call it manually.

@end deffn


@deffn Procedure cursyncup win

The routine @code{cursyncup} updates the current cursor position of
all the ancestors of the window to reflect the current cursor position
of the window.

The return value is unspecified.
@end deffn

@node Function key labels library, The curses panel library, The basic curses library, Curses Reference
@section The Function Key Label Library: @code{(ncurses slk)}

The @code{slk} functions in the @code{(ncurses slk)} library manipulate
the set of soft function-key labels that exist on many terminals.  For
those terminals that do not have soft labels, curses takes over the
bottom line of @code{stdscr}, reducing the size of @code{stdscr} (and
thus the return value of the procedure @code{lines}). curses
standardizes on eight labels of up to eight characters each. In
addition to this, the ncurses implementation supports a mode where it
simulates 12 labels of up to five characters each. This is most common
for today's PC like end-user devices.  Please note that ncurses
simulates this mode by taking over up to two lines at the bottom of
the screen, it doesn't try to use any hardware support for this mode.

This API is definitely in flux.

@deffn Procedure slk-init fmt

@findex initscr
@findex newterm
The @code{slk-init} routine must be called before @code{initscr} or
@code{newterm} is called.  If @code{initscr} eventually uses a line
from @code{stdscr} to emulate the soft labels, then @var{fmt}
determines how the labels are arranged on the screen.  Setting
@var{fmt} to @code{0} indicates a 3-2-3 arrangement of the labels,
@code{1} indicates a 4-4 arrangement and @code{2} indicates the
PC-like 4-4-4 mode. If @code{fmt} is set to 3, it is again the PC like
4-4-4 mode, but in addition an index line is generated, helping the
user to identify the key numbers easily.

It returns @code{#t} if @var{fmt} is a valid value, or @code{#f}
otherwise.

@end deffn

@deffn Procedure slk-set labnum label fmt
The @code{slk-set} routine requires @var{labnum} to be a label number,
from 1 to 8 (resp. 12); @var{label} must be the string to be put on
the label, up to eight (resp. five) characters in length.  @var{fmt}
is either 0, 1, or 2, indicating whether the label is to be
left-justified, centered, or right-justified, respectively, within
the label.

The procedure returns @code{#f} if the terminal or the softkeys
were not initialized, or the @var{labnum} parameter is outside the
range of label counts, or if the format parameter is outside the range
0..2, or if memory for the labels cannot be allocated. Otherwise it
return @code{#t}
@end deffn

@deffn Procedure slk-refresh
@deffnx Procedure slk-noutrefresh

These procedure do a @code{refresh} or @code{noutrefresh} operation on
the slk window.

@end deffn

@deffn Procedure slk-label labnum
The @code{slk-label} routine returns the current label for label
number @var{labnum}, with leading and trailing blanks stripped.
@end deffn

@deffn Procedure slk-clear
This routine clears the soft labels from the screen.
@end deffn

@deffn Procedure slk-restore
This procedure restores the soft labels after an @code{slk-clear} has
been performed.
@end deffn

@deffn Procedure slk-touch
This routine forces all the soft labels to be output next time
@code{slk-noutrefresh} is performed.
@end deffn

@deffn Procedure slk-attr-on! attrs
@deffnx Procedure slk-attr-off! attrs
@deffnx Procedure slk-attr-set! attrs color-pair
@deffnx Procedure slk-color! color-pair
@deffnx Procedure slk-attr

The @code{slk-attr-on!}, @code{slk-attr-set!}, and
@code{slk-attr-off!} routines correspond to @code{attr-on!},
@code{attr-set!}, @code{attr-off!}.  They have an effect only if soft
labels are simulated on the bottom line of the screen.  The default
highlight for soft keys is @code{A_STANDOUT}.

The @code{slk-color!} routine corresponds to @code{color-set!}. It has
an effect only if soft labels are simulated on the bottom line of the
screen.

The procedure @code{slk-attr} returns the attributes and color pair
currently set for the soft keys.  They are returned as a list of two
elements.  The first element is a bitmap of attributes; the second
element is a color pair number.
@end deffn


@node The curses panel library, The curses menu library, Function key labels library, Curses Reference
@section The curses panel library: @code{(ncurses panel)}

These are the functions in the @code{(ncurses panel)} module.

Panels are curses windows with the added feature of depth.  Panel
functions allow the use of stacked windows and ensure the proper
portions of each window and the curses @code{stdscr} window are hidden
or displayed when panels are added, moved, modified or removed.  The
set of currently visible panels is the stack of panels.  The
@code{stdscr} window is beneath all panels, and is not considered part
of the stack.

A window is associated with every panel. The panel routines enable you
to create, move, hide, and show panels, as well as position a panel at
any desired location in the stack.

Panel routines are a functional layer added to curses, make only
high-level curses calls, and work anywhere terminfo curses does.

@deffn Procedure new-panel win

This procedure allocates a PANEL structure, associates it with
@var{win}, places the panel on the top of the stack (causes it to be
displayed above any other panel) and returns the new panel.

@end deffn

@deffn Procedure update-panels

This procedure refreshes the virtual screen to reflect the relations
between the panels in the stack, but does not call @code{doupdate} to
refresh the physical screen.  Use this function and not @code{refresh}
or @code{noutrefresh}.  @code{update-panels} may be called more than
once before a call to @code{doupdate}, but @code{doupdate} is the
procedure responsible for updating the physical screen.

@end deffn


@deffn Procedure del-panel pan

This procedure removes the given panel from the stack and invalidates
@var{pan}

@end deffn

@deffn Procedure hide-panel pan

This procedure removes the given panel from the panel stack and thus
hides it from view. The panel @var{pan} is not lost, merely removed
from the stack.

@end deffn

@deffn Procedure panel-hidden? pan

This procedure returns @code{#t} if the panel is in the panel stack,
@code{#f} if it is not.

@end deffn

@deffn Procedure show-panel pan
This procedure makes a hidden panel visible by placing it on top of
the panels in the panel stack.
@end deffn

@deffn Procedure top-panel pan
This procedure puts the given visible panel on top of all panels in
the stack.
@end deffn

@deffn Procedure bottom-panel pan
This procedure puts the panel at the bottom of all panels.
@end deffn

@deffn Procedure move-panel pan starty startx
This procedure moves the given panel window so that its upper-left
corner is at @var{starty}, @var{startx}.  It does not change the
position of the panel in the stack.  Be sure to use this function, not
@code{mvwin}, to move a panel window.
@end deffn

@deffn Procedure replace-panel! pan window
This procedure replaces the current window of panel with window
(useful, for example if you want to resize a panel; It does not change
the position of the panel in the stack.
@end deffn


@deffn Procedure panel-window panel
Returns the window of a given panel
@end deffn

@node The curses menu library, The curses form library, The curses panel library, Curses Reference
@section The curses menu library: @code{(ncurses menu)}

These are the functions in the @code{(ncurses menu)} module.

@menu
* Menus Overview::
* Menu Item Procedures::
* Menu Procedures::
* Menu creation ::
* Menu options::
@end menu

@node Menus Overview, Menu Item Procedures, The curses menu library, The curses menu library
@subsection Menus Overview

Menu items are individual menu entries.  Each menu item has a name --
which is the short, usually single word, description of the item --
and a
description, which is a longer description of the menu item.
Depending on the format of the menu, the description may or many not
be visible.  Each menu item also holds a set of options about the
visibility and selectability of the item.

A menu is a collection of menu items along with options on how it
operates and is presented.

@node Menu Item Procedures, Menu Procedures, Menus Overview, The curses menu library
@subsection Menu Item Procedures

@deffn Procedure new-item name description
Returns a new allocated menu item of type with a given @var{name} and
@var{description}.  It can throw an error if the strings are too large
or if a memory allocation error occurs.
@end deffn

@deffn Procedure set-current-item! menu item
Given a @var{menu} and an @var{item} that has been attached to that
menu, this procedure sets @var{item} to be the current item.  It
returns an integer that will be one of @code{E_OK},
@code{E_BAD_ARGUMENT}, @code{E_NOT_CONNECTED} if not menu items are
attached to this menu, or @code{E_SYSTEM_ERROR}.
@end deffn

@deffn Procedure current-item menu
Returns the current item for @var{menu}.
@end deffn

@deffn Procedure set-top-row! menu row
This procedure sets @var{menu}'s top row to be @var{row}.  @var{row}
is an integer where zero indicates that the first row is the top row.

This procedure will only have an effect when there are more rows in
the menu than are displayed on the screen.  If all the menu items can
be displayed, this procedure will have no effect and return
@code{E_BAD_ARGUMENT}.

The number of rows and columns that a menu displays is set by
@code{set-menu-format!}.

It will return one of @code{E_OK}, @code{E_BAD_ARGUMENT},
@code{E_NOT_CONNECTED} if no menu items are attached to this menu, or
@code{E_SYSTEM_ERROR}.
@end deffn

@deffn Procedure top-row menu
Returns the number of the top menu row being displayed, or @code{#f}
on failure.
@end deffn

@deffn Procedure item-index item
This procedure returns the zero-origin index of this item in its
containing menu's item list or @code{#f} on failure.
@end deffn

@deffn Procedure item-name item
Returns, as a string, the name of the menu item @var{item}.
@end deffn

@deffn Procedure item-description item
Returns, as a string, the description of the menu item @var{item}.
@end deffn

@deffn Procedure set-item-opts! item opts
@deffnx Procedure item-opts-on! item opts
@deffnx Procedure item-opts-off! item opts
These functions set or query the bit mask for @var{item}.  There is
only one option bit mask, @code{O_SELECTABLE}.  When this is on, the
item may be selected during menu processing.  It defaults to on.

The procedure @code{set-item-opts} sets the bit mask of @var{item} to
@var{opts}.

The procedure @code{menu-opts-on} turns the bits of @var{opts} on in @var{item}.
The procedure @code{menu-opts-off} turns off the bits on @var{opts} in
@var{item}.

These routines will return @code{E_OK} on success or
@code{E_SYSTEM_ERROR} on failure.
@end deffn

@deffn Procedure item-opts item
This procedure returns the options bit mask of @var{item}.
@end deffn

@deffn Procedure set-item-value! item value
@deffnx Procedure item-value item
If the menu option @code{O_ONEVALUE} is turned off, the menu can have
more than one item selected simultaneously.  In this case, the
procedure @code{item-value} can be used to query @var{item} to see if
it is selected.  It returns @code{#t} or @code{#f}.

An item can be selected with the procedure @code{set-item-value!},
which takes a menu item and a boolean @var{value}.  It returns
@code{E_OK}, @code{E_SYSTEM_ERROR}, or @code{E_REQUEST_DENIED}.
@end deffn

@deffn Procedure item-visible? item
Returns @code{#t} if @var{item} is mapped onto the screen.  If a menu
has more menu items than can be displayed at once, only some of the
menu items will be mapped onto the screen.
@end deffn

@node Menu Procedures, Menu creation , Menu Item Procedures, The curses menu library
@subsection Menu Procedures

@menu
* Menu Colors and Attributes::
* Positioning a menu cursor::
* The menu driver::
* Menu sizes::
* Menu mark strings::
@end menu

@node Menu Colors and Attributes, Positioning a menu cursor, Menu Procedures, Menu Procedures
@subsubsection Menu Colors and Attributes

@deffn Procedure set-menu-fore! menu attr
@deffnx Procedure set-menu-back! menu attr
@deffnx Procedure set-menu-grey! menu attr
The procedure @code{set-menu-fore!} sets the colors and attributes
of selected menu items.  The default is @code{A_STANDOUT}.

The procedure @code{set-menu-back!} sets the colors and attributes of
selectable but not currently selected menu items.  Its default is
@code{A_NORMAL}.

The procedure @code{set-menu-grey!} sets the colors and attributes of
unselectable menu items for menus that allow multiple selections.  Its
default is @code{A_UNDERLINE}.
@end deffn

@deffn Procedure menu-fore menu
@deffnx Procedure menu-back menu
@deffnx Procedure menu-grey menu
These procedures return the colors and attributes of selected,
selectable, and unselectable menu items respectively.
@end deffn

@deffn Procedure set-menu-pad menu
This procedure sets the character used to fill the space between the
name and the description parts of a menu.
@end deffn

@deffn Procedure menu-pad menu
This procedure returns the character used to fill the space between
the name and description parts of a menu.
@end deffn

@deffn Procedure item-count menu
Returns the number of menu items attached to @var{menu}.
@end deffn

@node Positioning a menu cursor, The menu driver, Menu Colors and Attributes, Menu Procedures
@subsubsection Positioning a menu's cursor

@deffn Procedure pos-menu-cursor menu
This procedure repositions the cursor the position associated with the
menu's current selected item.  This is useful if other (non-menu)
routines have been called and have moved the cursor away from the
menu.
@end deffn

@node The menu driver, Menu sizes, Positioning a menu cursor, Menu Procedures
@subsubsection The menu driver

@deffn Procedure menu-driver menu c
Once a menu has been posted (displayed), you should funnel input events
to it through menu-driver.  This routine has three major input cases:

@itemize @bullet
@item
The input is a form navigation request.  Navigation request codes are
constants defined in the table below, which are distinct from the key
and character codes returned by @code{wgetch}.
@item
The input is a printable character.  Printable characters (which must
be positive, less than 256) are checked according to the program's
locale settings.
@item
The input is the KEY_MOUSE special key associated with an mouse event.
@end itemize

The menu driver request are as follows.

@table @code
@item REQ_LEFT_ITEM
Move left to an item.
@item REQ_RIGHT_ITEM
Move right to an item.
@item REQ_UP_ITEM
Move up to an item.
@item REQ_DOWN_ITEM
Move down to an item.
@item REQ_SCR_ULINE
Scroll up a line.
@item REQ_SCR_DLINE
Scroll down a line.
@item REQ_SCR_DPAGE
Scroll down a page.
@item REQ_SCR_UPAGE
Scroll up a page.
@item REQ_FIRST_ITEM
Move to the first item.
@item REQ_LAST_ITEM
Move to the last item.
@item REQ_NEXT_ITEM
Move to the next item.
@item REQ_PREV_ITEM
Move to the previous item.
@item REQ_TOGGLE_ITEM
Select/deselect an item.
@item REQ_CLEAR_PATTERN
Clear the menu pattern buffer.
@item REQ_BACK_PATTERN
Delete the previous character from the pattern buffer.
@item REQ_NEXT_MATCH
Move to the next item matching the pattern match.
@item REQ_PREV_MATCH
Move to the previous item matching the pattern match.
@end table

If the second argument @var{c} is a printable character, the code
appends it to the pattern buffer and attempts to move to the next item
matching the new pattern.  If there is no such match, menu-driver
returns @code{E_NO_MATCH} and deletes the appended character from the
buffer.

If the second argument @var{c} is one of the above pre-defined requests, the
corresponding action is performed.

If the second argument is the @code{KEY_MOUSE} special key, the
associated mouse event is translated into one of the above pre-defined
requests.  Currently only clicks in the user window (e.g. inside the
menu display area or the decoration window) are handled.

If you click above the display region of the menu:

@itemize @bullet
@item
a REQ_SCR_ULINE is generated for a single click,
@item
a REQ_SCR_UPAGE is generated for a double-click and
@item
a REQ_FIRST_ITEM is generated for a triple-click.
@end itemize

If you click below the display region of the menu:

@itemize @bullet
@item
a REQ_SCR_DLINE is generated for a single click,
@item
a REQ_SCR_DPAGE is generated for a double-click and
@item
a REQ_LAST_ITEM is generated for a triple-click.
@end itemize

If you click at an item inside the display area of the menu:
@itemize @bullet
@item
the menu cursor is positioned to that item.
@item
If you double-click an item a @code{REQ_TOGGLE_ITEM} is generated and
@code{E_UNKNOWN_COMMAND} is returned.  This return value makes sense,
because a double click usually means that an item-specific action
should be returned.  It is exactly the purpose of this return value to
signal that an application specific command should be executed.
@item
If a translation into a request was done, menu_driver returns the
result of this request.
@end itemize

If you clicked outside the user window or the mouse event could not be
translated into a menu request an E_REQUEST_DENIED is returned.

The procedure @code{menu-driver} returns one of the following error codes:

@table @code
@item E_OK
The routine succeeded.
@item E_SYSTEM_ERROR
System error occurred (see errno).
@item E_BAD_ARGUMENT
Routine detected an incorrect or out-of-range argument.
@item E_BAD_STATE
Routine was called from an initialization or termination function.
@item E_NOT_POSTED
The menu has not been posted.
@item E_UNKNOWN_COMMAND
The menu driver code saw an unknown request code.
@item E_NO_MATCH
Character failed to match.
@item E_REQUEST_DENIED
The menu driver could not process the request.
@end table

@end deffn

@node Menu sizes, Menu mark strings, The menu driver, Menu Procedures
@subsubsection Menu sizes
@deffn Procedure set-menu-format! menu rows cols
The procedure @code{set-menu-format!} sets the maximum display size of
the given menu.  If this size is too small to display all menu items,
the menu will be made scrollable. If this size is larger than the
menus subwindow and the subwindow is too small to display all menu
items, @code{post-menu} will fail.

The default format is 16 rows, 1 column. A zero row or column argument
is interpreted as a request not to change the
current value.

This procedure returns @code{E_OK}, @code{E_SYSTEM_ERROR},
@code{E_BAD_ARGUMENT} if the routine detected an incorrect or
out-of-range argument, or @code{E_POSTED} if the menu is already posted.
@end deffn

@deffn Procedure menu-format
This procedure returns a two-element list containing the display size
of the menu in rows and columns
@end deffn

@node Menu mark strings,  , Menu sizes, Menu Procedures
@subsubsection Menu mark strings
@deffn Procedure set-menu-mark! menu str
In order to make menu selections visible on older terminals without
highlighting or color capability, the menu library marks selected
items in a menu with a prefix string.

The function @code{set-menu-mark!} sets the mark string for the given
menu.  Calling @code{set-menu-mark!} with a null menu item will abolish
the mark string.  Note that changing the length of the mark string for
a menu while the menu is posted is likely to produce unhelpful
behavior.

The default string is ``-'' (a dash).
@end deffn

@deffn Procedure menu-mark menu
Returns, as a string, the prefix string used by the menu library to
designate the selected item.
@end deffn

@node Menu creation , Menu options, Menu Procedures, The curses menu library
@subsection Menu creation

@deffn Procedure new-menu items
Given a list of items, where each item was created by the procedure
@code{new-item}, the procedure @code{new-menu} returns a menu.

If the menu cannot be created, an error is thrown.
@end deffn

@node Menu options,  , Menu creation , The curses menu library
@subsection Menu options
@deffn Procedure set-menu-opts! menu options
@deffnx Procedure menu-opts-on! menu options
@deffnx Procedure menu-opts-off! menu options
The function @code{set-menu-opts!} sets all the given menu's option bits (menu
option bits may be logically-OR'ed together).

The function @code{menu-opts-on} turns on the given option bits, and
leaves others alone.

The function @code{menu-opts-off} turns off the given option bits, and
leaves others alone.

The following options are defined (all are on by default):
@table @code
@item O_ONEVALUE
Only one item can be selected for this menu.
@item O_SHOWDESC
Display the item descriptions when the menu is posted.
@item O_ROWMAJOR
Display the menu in row-major order.
@item O_IGNORECASE
Ignore the case when pattern-matching.
@item O_SHOWMATCH
Move the cursor to within the item name while
pattern-matching.
@item O_NONCYCLIC
Don't wrap around next-item and previous-item, requests to
the other end of the menu.
@end table

The procedure will return @code{E_OK}, @code{E_SYSTEM_ERROR}, or
@code{E_POSTED} if the menu is already posted.
@end deffn

@deffn Procedure menu-opts
Returns the bitmask of the @var{menu}'s options.
@end deffn

@menu
* Menu pattern buffer::
* Writing or erasing menus from window::
* Control spacing between menu items::
* Associate menus with window::
@end menu

@node Menu pattern buffer, Writing or erasing menus from window, Menu options, Menu options
@subsubsection Menu pattern buffer

@deffn Procedure set-menu-pattern! menu pattern
Every  menu  has an associated pattern match buffer.  As input
events that are printable characters come in,
they are appended to this match buffer and tested for a match,
as described in @code{menu-driver}.

The function @code{set-menu-pattern!} sets the pattern buffer for the
given menu and tries to find the first matching item.  If it succeeds,
that item becomes current; if not, the current item does not change.

It may return the following error codes: @code{E_OK},
@code{E_BAD_ARGUMENT}, @code{E_BAD_STATE} if the outline was called
from an initialization or termination function, @code{E_NO_MATCH} if
the character failed to match, or @code{E_SYSTEM_ERROR}.
@end deffn

@deffn Procedure menu-pattern menu
The procedure menu-pattern returns the pattern buffer of the given
menu.
@end deffn

@node Writing or erasing menus from window, Control spacing between menu items, Menu pattern buffer, Menu options
@subsubsection Writing or erasing menus from window
@deffn Procedure post-menu menu
@deffnx Procedure unpost-menu menu

The procedure @code{post-menu} displays a menu to its associated
subwindow.  To trigger physical display of the subwindow, use refresh
or some equivalent curses routine (the implicit doupdate triggered by
an curses input request will do). @code{post-menu} resets the
selection status of all items.

The procedure @code{unpost-menu} erases menu from its associated
subwindow.

These routines return one of the following: @code{E_OK},
@code{E_SYSTEM_ERROR}, @code{E_BAD_ARGUMENT}, @code{E_POSTED} if the
menu has already been posted, @code{E_BAD_STATE} if the routine was
called from an initialization or termination function,
@code{E_NO_ROOM} if the menu is too large for its window, or
@code{E_NOT_POSTED} if the menu has not been posted.
@end deffn

@node Control spacing between menu items, Associate menus with window, Writing or erasing menus from window, Menu options
@subsubsection Control spacing between menu items
@deffn Procedure set-menu-spacing! menu description rows cols
@deffnx Procedure menu-spacing menu

The procedure @code{set-menu-spacing!} sets the spacing information
for the menu.  The parameter @var{description} controls the number of
spaces between an item name and an item description. It must not be
larger than @code{TABSIZE}.  The menu system puts in the middle of
this spacing area the pad character. The remaining parts are filled
with spaces.  The parameter @var{rows} controls the number of rows
that are used for an item. It must not be larger than 3. The menu
system inserts the blank lines between item rows, these lines will
contain the pad character in the appropriate positions.  The parameter
@var{cols} controls the number of blanks between columns of items. It
must not be larger than @code{TABSIZE}.  A value of 0 for all the
spacing values resets them to the default, which is 1 for all of them.

@code{set-menu-spacing!} will return @code{E_OK}, @code{E_POSTED} if
the menu is posted, or @code{E_BAD_ARGUMENT} if one of the spacing
values is out of range.

The procedure @code{menu-spacing} returns the spacing info for the
menu as a list of three elements: description, row, and column spacing
@end deffn

@node Associate menus with window,  , Control spacing between menu items, Menu options
@subsubsection Associate menus with window
@deffn Procedure set-menu-win! menu win
@deffnx Procedure set-menu-sub! menu subwin
@deffnx Procedure menu-win menu
@deffnx Procedure menu-sub menu
@deffnx Procedure scale-menu menu
Every menu has an associated pair of curses windows.  The menu window
displays any title and border associated with the window; the menu
subwindow displays the items of the menu that are currently available
for selection.

The first four functions get and set those windows.  It is not
necessary to set either window; by default, the driver code uses
@code{stdscr} for both.

The procedure @code{scale-menu}returns the minimum size required for
the subwindow of @var{menu}.

@code{set-menu-win!} and @code{set-menu-sub!} will return one of the
following, @code{E_OK}, @code{E_SYSTEM_ERROR}, @code{E_BAD_ARGUMENT},
or @code{E_POSTED} if the menu has already been posted.
@end deffn

@node The curses form library,  , The curses menu library, Curses Reference
@section The curses form library: @code{(ncurses form)}

These are the functions in the @code{(ncurses form)} module.

@menu
* Forms Overview::
* Form procedures::
* Making or breaking connections between forms and fields::
* Color and attribute control for form fields::
* Data type validation for fields::
* Creating forms::
* Form pagination functions::
* Setting and getting form options::
* Setting the page number and field::
* Writing or erasing forms from associated subwindows::
* Printable form request names::
* Form windows::
@end menu

@node Forms Overview, Form procedures, The curses form library, The curses form library
@subsection Forms Overview

The form library provides terminal-independent facilities for
composing form screens on character-cell terminals.  The library
includes: field routines, which create and modify form fields; and
form routines, which group fields into forms, display forms on the
screen, and handle interaction with the user.



@subsection Positioning a form window cursor

@deffn Procedure pos-form-cursor form

The function  @code{pos-form-cursor}  restores	the  cursor  to          the  position
required for the forms driver to continue processing requests.  This is
useful after curses routines have been called to do screen-painting  in
response to a form operation.

It returns @code{E_OK} if the routine succeeded, @code{E_BAD_ARGUMENT}
if the routine detected an incorrect or out-of-range argument,
@code{E_NOT_POSTED} if the form has not been posted, or
@code{E_SYSTEM_ERROR} if a system error occurred.
@end deffn

@node  Form procedures, Making or breaking connections between forms and fields, Forms Overview, The curses form library
@subsection Form data

@deffn Procedure data-ahead? form
@deffnx Procedure data-behind? form
These procedures test if there is ahead or behind the current screen
of the given form @var{form}.  They return @code{#t} or @code{#f}.

This could be because a text entry has been declared to have variable
size (not O_STATIC) and not all text from the entry is being displayed.
@end deffn


@subsection Command-processing loop of the form system

@deffn Procedure form-driver form c

Once a form has been posted (displayed), you should funnel input
events to it through @code{form-driver}.  This routine has three major input
cases:

@itemize @bullet
@item
The input is a form navigation request.  Navigation request codes are
constants defined below, which are distinct from the key and character
codes returned by @code{wgetch}.
@item
The input is a printable character.  Printable characters (which must
be positive, less than 256) are checked according to the program's
locale settings.
@item
The input is the KEY_MOUSE special key associated with an mouse event.
@end itemize

The form driver requests are as follows:
@multitable {XXXXXXXXXXXXXXX} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}
@headitem Name              @tab Description

@item @code{REQ_NEXT_PAGE}
@tab  Move to the next page.
@item @code{REQ_PREV_PAGE}
@tab  Move to the previous page.
@item @code{REQ_FIRST_PAGE}
@tab  Move to the first page.
@item @code{REQ_LAST_PAGE}
@tab  Move to the last field.
@item @code{REQ_NEXT_FIELD}
@tab  Move to the next field.
@item @code{REQ_PREV_FIELD}
@tab  Move to the previous field.
@item @code{REQ_FIRST_FIELD}
@tab  Move to the first field.
@item @code{REQ_LAST_FIELD}
@tab  Move to the last field.
@item @code{REQ_SNEXT_FIELD}
@tab  Move to the sorted next field.
@item @code{REQ_SPREV_FIELD}
@tab  Move to the sorted previous field.
@item @code{REQ_SFIRST_FIELD}
@tab  Move to the sorted first field.
@item @code{REQ_SLAST_FIELD}
@tab  Move to the sorted last field.
@item @code{REQ_LEFT_FIELD}
@tab  Move left to a field.
@item @code{REQ_RIGHT_FIELD}
@tab  Move right to a field.
@item @code{REQ_UP_FIELD}
@tab  Move up to a field.
@item @code{REQ_DOWN_FIELD}
@tab  Move down to a field.
@item @code{REQ_NEXT_CHAR}
@tab  Move to the next char.
@item @code{REQ_PREV_CHAR}
@tab  Move to the previous char.
@item @code{REQ_NEXT_LINE}
@tab  Move to the next line.
@item @code{REQ_PREV_LINE}
@tab  Move to the previous line.
@item @code{REQ_NEXT_WORD}
@tab  Move to the next word.
@item @code{REQ_PREV_WORD}
@tab Move to the previous word.
@item @code{REQ_BEG_FIELD}
@tab  Move to the beginning of the field.
@item @code{REQ_END_FIELD}
@tab  Move to the end of the field.
@item @code{REQ_BEG_LINE}
@tab  Move to the beginning of the line.
@item @code{REQ_END_LINE}
@tab  Move to the end of the line.
@item @code{REQ_LEFT_CHAR}
@tab  Move left in the field.
@item @code{REQ_RIGHT_CHAR}
@tab  Move right in the field.
@item @code{REQ_UP_CHAR}
@tab  Move up in the field.
@item @code{REQ_DOWN_CHAR}
@tab  Move down in the field.
@item @code{REQ_NEW_LINE}
@tab  Insert or overlay a newline.
@item @code{REQ_INS_CHAR}
@tab  Insert a blank at the cursor.
@item @code{REQ_INS_LINE}
@tab  Insert a blank line at the cursor.
@item @code{REQ_DEL_CHAR}
@tab  Delete character at the cursor.
@item @code{REQ_DEL_PREV}
@tab  Delete character before the cursor.
@item @code{REQ_DEL_LINE}
@tab  Delete line at the cursor.
@item @code{REQ_DEL_WORD}
@tab  Delete blank-delimited word at the cursor.
@item @code{REQ_CLR_EOL}
@tab  Clear to end of line from cursor.
@item @code{REQ_CLR_EOF}
@tab  Clear to end of field from cursor.
@item @code{REQ_CLR_FIELD}
@tab  Clear the entire field.
@item @code{REQ_OVL_MODE}
@tab  Enter overlay mode.
@item @code{REQ_INS_MODE}
@tab  Enter insert mode.
@item @code{REQ_SCR_FLINE}
@tab  Scroll the field forward a line.
@item @code{REQ_SCR_BLINE}
@tab  Scroll the field backward a line.
@item @code{REQ_SCR_FPAGE}
@tab  Scroll the field forward a page.
@item @code{REQ_SCR_BPAGE}
@tab  Scroll the field backward a page.
@item @code{REQ_SCR_FHPAGE}
@tab  Scroll the field forward half a page.
@item @code{REQ_SCR_BHPAGE}
@tab  Scroll the field backward half a page.
@item @code{REQ_SCR_FCHAR}
@tab  Scroll the field forward a character.
@item @code{REQ_SCR_BCHAR}
@tab  Scroll the field backward a character.
@item @code{REQ_SCR_HFLINE}
@tab  Horizontal scroll the field forward a line.
@item @code{REQ_SCR_HBLINE}
@tab  Horizontal scroll the field backward a line.
@item @code{REQ_SCR_HFHALF}
@tab  Horizontal scroll the field forward half a line.
@item @code{REQ_SCR_HBHALF}
@tab  Horizontal scroll the field backward half a line.
@item @code{ REQ_VALIDATION}
@tab  Validate field.
@item @code{REQ_NEXT_CHOICE}
@tab  Display next field choice.
@item @code{REQ_PREV_CHOICE}
@tab  Display previous field choice.
@end multitable

If the second argument is a printable character, the driver places it
in the current position in the current field.  If it is one of the
forms requests listed above, that request is executed.


If the second argument is the @code{KEY_MOUSE} special key, the associated
mouse event is translated into one of the above pre-defined requests.
Currently only clicks in the user window (e.g. inside the form display
area or the decoration window) are handled.

If you click above the display region of the form:
@itemize @bullet
@item
a REQ_PREV_FIELD is generated for a single click,
@item
a REQ_PREV_PAGE is generated for a double-click and
@item
a REQ_FIRST_FIELD is generated for a triple-click.
@end itemize

If you click below the display region of the form:
@itemize @bullet
@item
a REQ_NEXT_FIELD is generated for a single click,
@item
a REQ_NEXT_PAGE is generated for a double-click and
@item
a REQ_LAST_FIELD is generated for a triple-click.
@end itemize

If you click at an field inside the display area of the form:
@itemize @bullet
@item
the form cursor is positioned to that field.
@item
If you double-click a field, the form cursor is positioned to that
field and @code{E_UNKNOWN_COMMAND} is returned.  This return value makes
sense, because a double click usually means that an field-specific
action should be returned.  It is exactly the purpose of this return
value to signal that an application specific command should be
executed.
@item
If a translation into a request was done, form_driver returns
the result of this request.
@end itemize

If you clicked outside the user window or the mouse event could not  be
translated into a form request an @code{E_REQUEST_DENIED} is returned.


If the second argument is neither printable nor one of the above
predefined form requests, the driver assumes it is an
application-specific command and returns @code{E_UNKNOWN_COMMAND}.
Application-defined commands should be defined relative to
@code{MAX_COMMAND}, the maximum value of these pre-defined requests.

@code{form-driver} returns one of the following error codes:
@code{E_OK} if the routine succeeded, @code{E_BAD_ARGUMENT} if the
routine detected an incorrect or out-of-range argument,
@code{E_BAD_STATE} if the routine was called from an initialization or
termination function, @code{E_NOT_POSTED} if the form has not been
posted, @code{E_INVALID_FIELD} if the contents of field is invalid,
@code{E_REQUEST_DENIED} if the form driver could not process the
request, @code{E_SYSTEM_ERROR} if a system error occurred, and
@code{E_UNKNOWN_COMMAND} if the form driver code saw an unknown
request code.

@end deffn


@node  Making or breaking connections between forms and fields, Color and attribute control for form fields, Form procedures, The curses form library
@subsection Making or breaking connections between forms and fields

@deffn Procedure set-form-fields form fields

This procedure takes a @var{fields}, which is a scheme list of field
types, and assigns them to @var{form}.

It returns an integer that will have the value @code{E_OK} on success,
@code{E_BAD_ARGUMENT}, @code{E_CONNECTED} if the fields are already
connected to the form, @code{E_POSTED} if the form is already posted,
or @code{E_SYSTEM_ERROR} if a system error occurred.

@end deffn

@deffn Procedure field-count form

Returns the number of fields in @code{form}.

@end deffn

@deffn Procedure move-field field row col

This moves the screen position of field to @var{row}, @var{col}.
The field must not be connected to a form.

It returns an integer that will have the value @code{E_OK} on success,
@code{E_BAD_ARGUMENT}, @code{E_CONNECTED} if the fields are already
connected to the form, @code{E_POSTED} if the form is already posted,
or @code{E_SYSTEM_ERROR} if a system error occurred.

@end deffn



@node  Color and attribute control for form fields, Data type validation for fields, Making or breaking connections between forms and fields, The curses form library
@subsection Color and attribute control for form fields

@deffn Procedure set-field-fore! field attr
@deffnx Procedure set-field-back! field attr

The procedure @code{set-field-fore!} sets the attributes of the contents
of a field, and @code{set-field-back!} set the attributes of the unused
portion of a field.

They return the constants @code{E_OK} on success, @code{E_BAD_ARGUMENT},
or @code{E_SYSTEM_ERROR}.

@end deffn

@deffn Procedure field-fore field
@deffnx Procedure field-back field

The procedure @code{field-fore} returns the attributes of the contents
of a field, and @code{field-back} returns the attributes of the unused
portion of a field.

@end deffn

@deffn Procedure set-field-pad! field pad

The procedure @code{set-field-pad!} sets the character used as blank in
the field to the codepoint @code{pad}.

They return the constants @code{E_OK} on success, @code{E_BAD_ARGUMENT},
or @code{E_SYSTEM_ERROR}.

@end deffn

@deffn Procedure field-pad field

The procedure @code{field-pad} returns the codepoint used as the blank
in @code{field}.

@end deffn


@subsection Field buffer control

There are functions to set and get the text in a field, as well as to
check if that field has been modified.

@deffn Procedure set-field-buffer! field buf value
The function @code{set-field-buffer!} sets the numbered buffer of the
given field to contain a given string.  Buffer 0 is the displayed
value of the field; other numbered buffers may be allocated by
applications through the @var{nbuf} argument of @code{new-field}
but are not manipulated by the forms library.
@end deffn

@deffn Procedure field-buffer field buffer
Returns a string that is the contents of the @var{field}.
@var{buffer} zero is the visible buffer on the screen.  A field may
have other buffers if so allocated when the field was created using
@code{new-field}.
@end deffn

@deffn Procedure field-status? field
The returns the field status of @var{field}.  The field status is set
to a non-zero value whenever the field changes.
@end deffn

@deffn Procedure set-field-status! field status
Sets the field status of @var{field} to @var{status}, a boolean.
@end deffn

@deffn Procedure set-max-field field max
This procedure sets the maximum size for a dynamic field.  An argument
of zero turns off any maximum size threshold for that field.
@end deffn

@subsection Retrieving field characteristics

@deffn Procedure field-info field
The procedure returns a six-element list of information about the
field.  The elements of the list are: height, width, row of upper-left
corner, column of upper-left corner, number of off-screen rows, and
number of working buffers.  This information was stored when the field
was created, and rows and columns may not be accurate.
@end deffn

@deffn Procedure dynamic-field-info field
This procedure returns of the actual size of the field and its maximum
size as a list.  The elements of the list are: rows, column, and max
size.
@end deffn

@subsection Retrieving field characteristics

@deffn Procedure set-field-just! field justification
This procedure sets the justification attribute of a field to one of
@code{NO_JUSTIFICATION}, @code{JUSTIFY_RIGHT}, @code{JUSTIFY_LEFT}, or
@code{JUSTIFY_CENTER}.
@end deffn

@deffn Procedure field-just field
This procedure returns the justification attribute of @var{field}.  It
is one of @code{NO_JUSTIFICATION}, @code{JUSTIFY_RIGHT},
@code{JUSTIFY_LEFT}, or @code{JUSTIFY_CENTER}.
@end deffn

@subsection Creating and destroying form fields

@deffn Procedure new-field height width toprow leftcol offscreen nbuffers
The function @code{new-field} allocates a new field and initializes it
from the parameters given: height, width, row of upper-left corner,
column of upper-left corner, number off-screen rows, and number of
additional working buffers.
@end deffn

@deffn Procedure dup-field field toprow leftcol
The function dup-field duplicates a field at a new location.  Most
attributes (including current contents, size, validation type, buffer
count, growth threshold, justification, foreground, background, pad
character, options, and user pointer) are copied.  Field status and
the field page bit are not copied.
@end deffn

@deffn Procedure link-field field toprow leftcol
This is like @code{dup-field} except that the new field shares buffers
with its parent.  Attribute data is separate.
@end deffn

@deffn Procedure free-field field
This explicitly releases the buffer in field, instead of waiting for
the garbage collector to take care of it.
@end deffn

@subsection Setting and getting field options
@deffn Procedure set-field-opts! field opts
@deffnx Procedure field-opts-on! field opts
@deffnx Procedure field-opts-off! field opts
@deffnx Procedure field-opts field
The function @code{set-field-opts!} sets all the given field's option
bits (field option bits may be logically-OR'ed together).

The function @code{field-opts-on!} turns on the given option bits, and
leaves others alone.

The function @code{field-opts-off!} turns off the given option bits, and leaves
others alone.

The function @code{field-opts} returns the field's current option
bits.
@end deffn

The following options are defined.  All are on by default

@table @code
@item O_VISIBLE
The field is displayed.  If this option is off, display of the field
is suppressed.
@item O_ACTIVE
The field is visited during processing. If this option is off, the
field will not be reachable by navigation keys. Please notice that an
invisible field appears to be inactive also.
@item O_PUBLIC
The field contents are displayed as data is entered.
@item O_EDIT
The field can be edited.
@item O_WRAP
Words that do not fit on a line are wrapped to the next line.  Words
are blank-separated.
@item O_BLANK
The field is cleared whenever a character is entered at the first
position.
@item O_AUTOSKIP
Skip to the next field when this one fills.
@item O_NULLOK
Allow a blank field.
@item O_STATIC
Field buffers are fixed to field's original size.  Turn this option
off to create a dynamic field.
@item O_PASSOK
Validate field only if modified by user.
@end table

@node Data type validation for fields, Creating forms, Color and attribute control for form fields, The curses form library
@subsection Data type validation for fields
These functions set a field to be able to contain only a certain type
of input.  The user will not be able to move off the field if it
contains invalid input.

@deffn Procedure set-field-type! field type @dots{}
@deffnx Procedure field-type field
The procedure @code{set-field-type!} declares a data type for a given
form field.  The procedure @code{field-type} returns the declared data
type.  The input @var{type} is a symbol that is one of the following
list.  This is the type checked by validation functions.  The
predefined types are as follows:

@table @code
@item TYPE_ALNUM
Alphanumeric data. Requires a third int argument, a minimum field
width.
@item TYPE_ALPHA
Character data.  Requires a third int argument, a minimum field width.
@item TYPE_ENUM
Accept one of a specified set of strings.  Requires a third argument
pointing to a list of strings; a fourth integer flag argument to
enable case-sensitivity; and a fifth int flag argument specifying
whether a partial match must be a unique one (if this flag is off, a
prefix matches the first of any set of more than one list elements
with that prefix). Please notice that the string list is not copied,
only a reference to it is stored in the field. So you should avoid
using a list that lives in automatic variables on the stack.
@item TYPE_INTEGER
Integer data.  Requires a third int argument controlling the
precision, a fourth long argument constraining minimum value, and a
fifth long constraining maximum value.  If the maximum value is less
than or equal to the minimum value, the range is simply ignored.
@item TYPE_NUMERIC
Numeric data (may have a decimal-point part). Requires a third int
argument controlling the precision, a fourth double argument con-
straining minimum value, and a fifth double constraining maximum
value. If your system supports locales, the decimal point character
to be used must be the one specified by your locale. If the maximum
value is less than or equal to the minimum value, the range is simply
ignored.
@item TYPE_REGEXP
Regular expression data.  Requires a regular expression (char *) third
argument; the data is valid if the regular expression matches it.
Regular expressions are in the format of regcomp and regexec.  Please
notice that the regular expression must match the whole field. If you
have for example an eight character wide field, a regular expression
"^[0-9]*$" always means that you have to fill all eight positions with
digits.  If you want to allow fewer digits, you may use for example
"^[0-9]* *$" which is good for trailing spaces (up to an empty field),
or "^ *[0-9]* *$" which is good for leading and trailing spaces around
the digits.
@item TYPE_IPV4
An Internet Protocol Version 4 address. This requires no additional
argument. It is checked whether or not the buffer has the form
a.b.c.d, where a,b,c and d are numbers between 0 and 255.  Trailing
blanks in the buffer are ignored. The address itself is not
validated. Please note that this is an ncurses extension. This field
type may not be available in other curses implementations.
@end table

@end deffn

@node Creating forms, Form pagination functions, Data type validation for fields, The curses form library
@subsection Creating forms

@deffn Procedure new-form fields
Creates a new form given a list that contains fields.  The fields are
created using @code{new-field}.
@end deffn

@node Form pagination functions, Setting and getting form options, Creating forms, The curses form library
@subsection Form pagination functions

@deffn Procedure set-new-page field new-page-flag
This procedure sets or resets a flag marking the given field as
beginning a new page on its form.
@end deffn

@deffn Procedure new-page? field
Returns a flag indicating if the given field is the start of a new
page on its form.
@end deffn

@node Setting and getting form options, Setting the page number and field, Form pagination functions, The curses form library
@subsection Setting and getting form options

@deffn Procedure set-form-opts form opts
@deffnx Procedure form-opts-on! form opts
@deffnx Procedure form-opts-off! form opts
The function @code{set-form-opts} sets all the given form's option bits (form
option bits may be logically-OR'ed together).

The function @code{form-opts-on!} turns on the given option bits, and leaves
others alone.

The function @code{form-opts-off!} turns off the given option bits, and	leaves
others alone.
@end deffn

@deffn Procedure form-opts form
This returns the current option bits for the form.
@end deffn

The following options are defined, and all are on by default.

@table @code
@item  O_NL_OVERLOAD
Overload the @code{REQ_NEW_LINE} forms driver request so that calling it at
the end of a field goes to the next field.
@item O_BS_OVERLOAD
Overload the @code{REQ_DEL_PREV} forms driver request so that calling  it
at the beginning of a field goes to the previous field.
@end table

@node Setting the page number and field, Writing or erasing forms from associated subwindows, Setting and getting form options, The curses form library
@subsection Setting the page number and field

@deffn Procedure set-current-field! form field
This procedure sets the current field on the form.
@end deffn

@deffn Procedure field-index form
This returns the index into the field array that is current for the
form.
@end deffn

@deffn Procedure set-form-page form n
Sets the page of the form to @var{n}.
@end deffn

@deffn Procedure form-page form
Returns the current form's displayed page number.
@end deffn

@node Writing or erasing forms from associated subwindows, Printable form request names, Setting the page number and field, The curses form library
@subsection Writing or erasing forms from associated subwindows

@deffn Procedure post-form form
This procedure displays a form to its associated subwindow.  To
trigger physical display of the subwindow, use @code{refresh} or some
equivalent routine.
@end deffn

@deffn Procedure unpost-form form
This erases the form from its associated subwindow.
@end deffn

@node Printable form request names, Form windows, Writing or erasing forms from associated subwindows, The curses form library
@subsection Printable form request names

@deffn Procedure form-request-name request
@deffnx Procedure form-request-by-name name
These procedures convert a string containing the printable name of a
form request to its integer value and vice versa.
@end deffn

@node Form windows,  , Printable form request names, The curses form library
@subsection Form windows

@deffn Procedure set-form-win form win
@deffnx Procedure form-win form
@deffnx Procedure set-form-sub form sub
@deffnx Procedure form-sub form
@deffnx Procedure scale-form form
Every form has an associated pair of curses windows.  The form window
displays any title and border associated with the window; the form
sub-window displays the items of the form that are currently
available for selection.

The first four functions get and set those windows.  It is not
necessary to set either window; by default, the driver code uses
@code{stdscr} for both.

The function scale-form returns the a list of two elements: minimum
size required for the subwindow of form.
@end deffn

@node Index,  , Curses Reference, Top
@unnumbered Index
@printindex cp
@bye
